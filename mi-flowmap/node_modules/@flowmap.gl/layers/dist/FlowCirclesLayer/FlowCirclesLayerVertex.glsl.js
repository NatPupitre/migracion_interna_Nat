/*
 * Copyright (c) Flowmap.gl contributors
 * Copyright (c) 2018-2020 Teralytics
 * SPDX-License-Identifier: Apache-2.0
 */
export default `\
#define SHADER_NAME flow-circles-layer-vertex-shader
#define radiusScale 100

attribute vec3 positions;

attribute vec3 instancePositions;
attribute vec3 instancePositions64Low;
attribute float instanceInRadius;
attribute float instanceOutRadius;
attribute vec4 instanceColors;
attribute vec3 instancePickingColors;

uniform float opacity;
uniform vec4 emptyColor;
uniform float outlineEmptyMix;

varying vec4 vColor;
varying vec2 unitPosition;
varying float unitInRadius;
varying float unitOutRadius;

void main(void) {
  geometry.worldPosition = instancePositions;

  float outerRadiusPixels = max(instanceInRadius, instanceOutRadius);
  unitInRadius = instanceInRadius / outerRadiusPixels; 
  unitOutRadius = instanceOutRadius / outerRadiusPixels; 

  // position on the containing square in [-1, 1] space
  unitPosition = positions.xy;
  geometry.uv = unitPosition;
  geometry.pickingColor = instancePickingColors;
                                                                                                    
  // Find the center of the point and add the current vertex
  vec3 offset = positions * project_pixel_size(outerRadiusPixels);
  DECKGL_FILTER_SIZE(offset, geometry);
  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
                            
  // Apply opacity to instance color, or return instance picking color
  vColor = vec4(instanceColors.rgb / 255., instanceColors.a / 255. * opacity);
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmxvd0NpcmNsZXNMYXllclZlcnRleC5nbHNsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL0Zsb3dDaXJjbGVzTGF5ZXIvRmxvd0NpcmNsZXNMYXllclZlcnRleC5nbHNsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7O0dBSUc7QUFDSCxlQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTRDZCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgRmxvd21hcC5nbCBjb250cmlidXRvcnNcbiAqIENvcHlyaWdodCAoYykgMjAxOC0yMDIwIFRlcmFseXRpY3NcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGBcXFxuI2RlZmluZSBTSEFERVJfTkFNRSBmbG93LWNpcmNsZXMtbGF5ZXItdmVydGV4LXNoYWRlclxuI2RlZmluZSByYWRpdXNTY2FsZSAxMDBcblxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zO1xuXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zNjRMb3c7XG5hdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VJblJhZGl1cztcbmF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZU91dFJhZGl1cztcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlQ29sb3JzO1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xuXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG51bmlmb3JtIHZlYzQgZW1wdHlDb2xvcjtcbnVuaWZvcm0gZmxvYXQgb3V0bGluZUVtcHR5TWl4O1xuXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xudmFyeWluZyB2ZWMyIHVuaXRQb3NpdGlvbjtcbnZhcnlpbmcgZmxvYXQgdW5pdEluUmFkaXVzO1xudmFyeWluZyBmbG9hdCB1bml0T3V0UmFkaXVzO1xuXG52b2lkIG1haW4odm9pZCkge1xuICBnZW9tZXRyeS53b3JsZFBvc2l0aW9uID0gaW5zdGFuY2VQb3NpdGlvbnM7XG5cbiAgZmxvYXQgb3V0ZXJSYWRpdXNQaXhlbHMgPSBtYXgoaW5zdGFuY2VJblJhZGl1cywgaW5zdGFuY2VPdXRSYWRpdXMpO1xuICB1bml0SW5SYWRpdXMgPSBpbnN0YW5jZUluUmFkaXVzIC8gb3V0ZXJSYWRpdXNQaXhlbHM7IFxuICB1bml0T3V0UmFkaXVzID0gaW5zdGFuY2VPdXRSYWRpdXMgLyBvdXRlclJhZGl1c1BpeGVsczsgXG5cbiAgLy8gcG9zaXRpb24gb24gdGhlIGNvbnRhaW5pbmcgc3F1YXJlIGluIFstMSwgMV0gc3BhY2VcbiAgdW5pdFBvc2l0aW9uID0gcG9zaXRpb25zLnh5O1xuICBnZW9tZXRyeS51diA9IHVuaXRQb3NpdGlvbjtcbiAgZ2VvbWV0cnkucGlja2luZ0NvbG9yID0gaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAvLyBGaW5kIHRoZSBjZW50ZXIgb2YgdGhlIHBvaW50IGFuZCBhZGQgdGhlIGN1cnJlbnQgdmVydGV4XG4gIHZlYzMgb2Zmc2V0ID0gcG9zaXRpb25zICogcHJvamVjdF9waXhlbF9zaXplKG91dGVyUmFkaXVzUGl4ZWxzKTtcbiAgREVDS0dMX0ZJTFRFUl9TSVpFKG9mZnNldCwgZ2VvbWV0cnkpO1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfcG9zaXRpb25fdG9fY2xpcHNwYWNlKGluc3RhbmNlUG9zaXRpb25zLCBpbnN0YW5jZVBvc2l0aW9uczY0TG93LCBvZmZzZXQsIGdlb21ldHJ5LnBvc2l0aW9uKTtcbiAgREVDS0dMX0ZJTFRFUl9HTF9QT1NJVElPTihnbF9Qb3NpdGlvbiwgZ2VvbWV0cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAvLyBBcHBseSBvcGFjaXR5IHRvIGluc3RhbmNlIGNvbG9yLCBvciByZXR1cm4gaW5zdGFuY2UgcGlja2luZyBjb2xvclxuICB2Q29sb3IgPSB2ZWM0KGluc3RhbmNlQ29sb3JzLnJnYiAvIDI1NS4sIGluc3RhbmNlQ29sb3JzLmEgLyAyNTUuICogb3BhY2l0eSk7XG4gIERFQ0tHTF9GSUxURVJfQ09MT1IodkNvbG9yLCBnZW9tZXRyeSk7XG59XG5gO1xuIl19