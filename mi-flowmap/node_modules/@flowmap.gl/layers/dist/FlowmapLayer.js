/*
 * Copyright (c) Flowmap.gl contributors
 * Copyright (c) 2018-2020 Teralytics
 * SPDX-License-Identifier: Apache-2.0
 */
import { CompositeLayer } from '@deck.gl/core';
import { ScatterplotLayer, TextLayer } from '@deck.gl/layers';
import { FlowmapAggregateAccessors, LocalFlowmapDataProvider, colorAsRgba, getFlowLineAttributesByIndex, getFlowmapColors, getLocationCoordsByIndex, getOuterCircleRadiusByIndex, isFlowmapData, isFlowmapDataProvider, } from '@flowmap.gl/data';
import AnimatedFlowLinesLayer from './AnimatedFlowLinesLayer';
import FlowCirclesLayer from './FlowCirclesLayer';
import FlowLinesLayer from './FlowLinesLayer';
import { PickingType, } from './types';
const PROPS_TO_CAUSE_LAYER_DATA_UPDATE = [
    'filter',
    'locationsEnabled',
    'locationTotalsEnabled',
    'locationLabelsEnabled',
    'adaptiveScalesEnabled',
    'animationEnabled',
    'clusteringEnabled',
    'clusteringLevel',
    'fadeEnabled',
    'fadeOpacityEnabled',
    'clusteringAuto',
    'darkMode',
    'fadeAmount',
    'colorScheme',
    'highlightColor',
    'maxTopFlowsDisplayNum',
];
var HighlightType;
(function (HighlightType) {
    HighlightType["LOCATION"] = "location";
    HighlightType["FLOW"] = "flow";
})(HighlightType || (HighlightType = {}));
class FlowmapLayer extends CompositeLayer {
    constructor(props) {
        super({
            ...props,
            onHover: (info, event) => {
                const startTime = Date.now();
                this.setState({
                    highlightedObject: this._getHighlightedObject(info),
                    lastHoverTime: startTime,
                });
                const { onHover } = props;
                if (onHover) {
                    this._getFlowmapLayerPickingInfo(info).then((info) => {
                        if ((this.state?.lastHoverTime ?? 0) <= startTime) {
                            this.setState({ pickingInfo: info });
                            onHover(info, event);
                        }
                        else {
                            // Skipping, because this is not the latest hover event
                        }
                    });
                }
            },
            onClick: (info, event) => {
                const { onClick } = props;
                const startTime = Date.now();
                this.setState({
                    lastClickTime: startTime,
                });
                if (onClick) {
                    this._getFlowmapLayerPickingInfo(info).then((info) => {
                        if ((this.state?.lastClickTime ?? 0) <= startTime) {
                            this.setState({ pickingInfo: info });
                            if (info) {
                                onClick(info, event);
                            }
                        }
                        else {
                            // Skipping, because this is not the latest hover event
                        }
                    });
                }
            },
        });
    }
    initializeState() {
        this.state = {
            accessors: new FlowmapAggregateAccessors(this.props),
            dataProvider: this._getOrMakeDataProvider(),
            layersData: undefined,
            highlightedObject: undefined,
            pickingInfo: undefined,
            lastHoverTime: undefined,
            lastClickTime: undefined,
        };
    }
    getPickingInfo({ info }) {
        // This is for onHover event handlers set on the <DeckGL> component
        if (!info.object) {
            const object = this.state?.pickingInfo?.object;
            if (object) {
                return {
                    ...info,
                    object,
                    picked: true,
                };
            }
        }
        return info;
    }
    // private _updateAccessors() {
    //   this.state?.dataProvider?.setAccessors(this.props);
    //   this.setState({accessors: new FlowmapAggregateAccessors(this.props)});
    // }
    _getOrMakeDataProvider() {
        const { data, dataProvider } = this.props;
        if (isFlowmapDataProvider(dataProvider)) {
            return dataProvider;
        }
        else if (isFlowmapData(data)) {
            const dataProvider = new LocalFlowmapDataProvider(this.props);
            dataProvider.setFlowmapData(data);
            return dataProvider;
        }
        throw new Error('FlowmapLayer: data must be a FlowmapDataProvider or FlowmapData');
    }
    _updateDataProvider() {
        this.setState({ dataProvider: this._getOrMakeDataProvider() });
    }
    shouldUpdateState(params) {
        const { changeFlags } = params;
        // if (this._viewportChanged()) {
        //   return true;
        // }
        if (changeFlags.viewportChanged) {
            return true;
        }
        return super.shouldUpdateState(params);
        // TODO: be smarter on when to update
        // (e.g. ignore viewport changes when adaptiveScalesEnabled and clustering are false)
    }
    updateState({ oldProps, props, changeFlags }) {
        if (changeFlags.propsChanged) {
            // this._updateAccessors();
        }
        if (changeFlags.dataChanged) {
            this._updateDataProvider();
        }
        if (changeFlags.viewportChanged || changeFlags.dataChanged) {
            this.setState({ highlightedObject: undefined });
        }
        if (changeFlags.viewportChanged ||
            changeFlags.dataChanged ||
            (changeFlags.propsChanged &&
                PROPS_TO_CAUSE_LAYER_DATA_UPDATE.some((prop) => oldProps[prop] !== props[prop]))) {
            const { dataProvider } = this.state || {};
            if (dataProvider) {
                dataProvider.setFlowmapState(this._getFlowmapState());
                dataProvider.updateLayersData((layersData) => {
                    this.setState({ layersData, highlightedObject: undefined });
                }, changeFlags);
            }
        }
    }
    _getSettingsState() {
        const { locationsEnabled, locationTotalsEnabled, locationLabelsEnabled, adaptiveScalesEnabled, animationEnabled, clusteringEnabled, clusteringLevel, fadeEnabled, fadeOpacityEnabled, clusteringAuto, darkMode, fadeAmount, colorScheme, highlightColor, maxTopFlowsDisplayNum, } = this.props;
        return {
            locationsEnabled,
            locationTotalsEnabled,
            locationLabelsEnabled,
            adaptiveScalesEnabled,
            animationEnabled,
            clusteringEnabled,
            clusteringLevel,
            fadeEnabled,
            fadeOpacityEnabled,
            clusteringAuto,
            darkMode,
            fadeAmount,
            colorScheme,
            highlightColor,
            maxTopFlowsDisplayNum,
        };
    }
    _getFlowmapState() {
        return {
            viewport: pickViewportProps(this.context.viewport),
            filter: this.props.filter,
            settings: this._getSettingsState(),
        };
    }
    async _getFlowmapLayerPickingInfo(info) {
        const { index, sourceLayer } = info;
        const { dataProvider, accessors } = this.state || {};
        if (!dataProvider || !accessors) {
            return undefined;
        }
        const commonInfo = {
            ...info,
            picked: info.picked,
            layer: info.layer,
            index: info.index,
            x: info.x,
            y: info.y,
            coordinate: info.coordinate,
            event: info.event,
        };
        if (sourceLayer instanceof FlowLinesLayer ||
            sourceLayer instanceof AnimatedFlowLinesLayer) {
            const flow = index === -1 ? undefined : await dataProvider.getFlowByIndex(index);
            if (flow) {
                const origin = await dataProvider.getLocationById(accessors.getFlowOriginId(flow));
                const dest = await dataProvider.getLocationById(accessors.getFlowDestId(flow));
                if (origin && dest) {
                    return {
                        ...commonInfo,
                        object: {
                            type: PickingType.FLOW,
                            flow,
                            origin: origin,
                            dest: dest,
                            count: accessors.getFlowMagnitude(flow),
                        },
                    };
                }
            }
        }
        else if (sourceLayer instanceof FlowCirclesLayer) {
            const location = index === -1 ? undefined : await dataProvider.getLocationByIndex(index);
            if (location) {
                const id = accessors.getLocationId(location);
                const name = accessors.getLocationName(location);
                const totals = await dataProvider.getTotalsForLocation(id);
                const { circleAttributes } = this.state?.layersData || {};
                if (totals && circleAttributes) {
                    const circleRadius = getOuterCircleRadiusByIndex(circleAttributes, info.index);
                    return {
                        ...commonInfo,
                        object: {
                            type: PickingType.LOCATION,
                            location,
                            id,
                            name,
                            totals,
                            circleRadius: circleRadius,
                        },
                    };
                }
            }
        }
        return undefined;
    }
    _getHighlightedObject(info) {
        const { index, sourceLayer } = info;
        if (index < 0)
            return undefined;
        if (sourceLayer instanceof FlowLinesLayer ||
            sourceLayer instanceof AnimatedFlowLinesLayer) {
            const { lineAttributes } = this.state?.layersData || {};
            if (lineAttributes) {
                let attrs = getFlowLineAttributesByIndex(lineAttributes, index);
                if (this.props.fadeOpacityEnabled) {
                    attrs = {
                        ...attrs,
                        attributes: {
                            ...attrs.attributes,
                            getColor: {
                                ...attrs.attributes.getColor,
                                value: new Uint8Array([
                                    ...attrs.attributes.getColor.value.slice(0, 3),
                                    255, // the highlight color should be always opaque
                                ]),
                            },
                        },
                    };
                }
                return {
                    type: HighlightType.FLOW,
                    lineAttributes: attrs,
                };
            }
        }
        else if (sourceLayer instanceof FlowCirclesLayer) {
            const { circleAttributes } = this.state?.layersData || {};
            if (circleAttributes) {
                return {
                    type: HighlightType.LOCATION,
                    coords: getLocationCoordsByIndex(circleAttributes, index),
                    radius: getOuterCircleRadiusByIndex(circleAttributes, index),
                };
            }
        }
        return undefined;
    }
    renderLayers() {
        const layers = [];
        if (this.state?.layersData) {
            const { layersData, highlightedObject } = this.state;
            const { circleAttributes, lineAttributes, locationLabels } = layersData || {};
            if (circleAttributes && lineAttributes) {
                const flowmapColors = getFlowmapColors(this._getSettingsState());
                const outlineColor = colorAsRgba(flowmapColors.outlineColor || (this.props.darkMode ? '#000' : '#fff'));
                const commonLineLayerProps = {
                    data: lineAttributes,
                    parameters: {
                        ...this.props.parameters,
                        // prevent z-fighting at non-zero bearing/pitch
                        depthTest: false,
                    },
                };
                if (this.props.animationEnabled) {
                    layers.push(
                    // @ts-ignore
                    new AnimatedFlowLinesLayer({
                        ...this.getSubLayerProps({
                            ...commonLineLayerProps,
                            id: 'animated-flow-lines',
                            drawOutline: false,
                            thicknessUnit: 20,
                        }),
                    }));
                }
                else {
                    layers.push(new FlowLinesLayer({
                        ...this.getSubLayerProps({
                            ...commonLineLayerProps,
                            id: 'flow-lines',
                            drawOutline: true,
                            outlineColor: outlineColor,
                        }),
                    }));
                }
                layers.push(new FlowCirclesLayer(this.getSubLayerProps({
                    id: 'circles',
                    data: circleAttributes,
                    emptyColor: this.props.darkMode
                        ? [0, 0, 0, 255]
                        : [255, 255, 255, 255],
                    outlineEmptyMix: 0.4,
                })));
                if (highlightedObject) {
                    switch (highlightedObject.type) {
                        case HighlightType.LOCATION:
                            layers.push(new ScatterplotLayer({
                                ...this.getSubLayerProps({
                                    id: 'location-highlight',
                                    data: [highlightedObject],
                                    pickable: false,
                                    antialiasing: true,
                                    stroked: true,
                                    filled: false,
                                    lineWidthUnits: 'pixels',
                                    getLineWidth: 2,
                                    radiusUnits: 'pixels',
                                    getRadius: (d) => d.radius,
                                    getLineColor: colorAsRgba(this.props.highlightColor),
                                    getPosition: (d) => d.coords,
                                }),
                            }));
                            break;
                        case HighlightType.FLOW:
                            layers.push(new FlowLinesLayer({
                                ...this.getSubLayerProps({
                                    id: 'flow-highlight',
                                    data: highlightedObject.lineAttributes,
                                    drawOutline: true,
                                    pickable: false,
                                    outlineColor: colorAsRgba(this.props.highlightColor),
                                    outlineThickness: 1,
                                    parameters: {
                                        depthTest: false,
                                    },
                                }),
                            }));
                            break;
                    }
                }
            }
            if (locationLabels) {
                layers.push(new TextLayer(this.getSubLayerProps({
                    id: 'location-labels',
                    data: locationLabels,
                    maxWidth: 1000,
                    pickable: false,
                    fontFamily: 'Helvetica',
                    getPixelOffset: (d, { index }) => {
                        const r = getOuterCircleRadiusByIndex(circleAttributes, index);
                        return [0, r + 5];
                    },
                    getPosition: (d, { index }) => {
                        const pos = getLocationCoordsByIndex(circleAttributes, index);
                        return pos;
                    },
                    getText: (d) => d,
                    getSize: 10,
                    getColor: [255, 255, 255, 255],
                    getAngle: 0,
                    getTextAnchor: 'middle',
                    getAlignmentBaseline: 'top',
                })));
            }
        }
        return layers;
    }
}
FlowmapLayer.defaultProps = {
    darkMode: true,
    fadeAmount: 50,
    locationsEnabled: true,
    locationTotalsEnabled: true,
    locationLabelsEnabled: false,
    animationEnabled: false,
    clusteringEnabled: true,
    fadeEnabled: true,
    fadeOpacityEnabled: false,
    clusteringAuto: true,
    clusteringLevel: undefined,
    adaptiveScalesEnabled: true,
    colorScheme: 'Teal',
    highlightColor: 'orange',
    maxTopFlowsDisplayNum: 5000,
};
export default FlowmapLayer;
function pickViewportProps(viewport) {
    const { width, height, longitude, latitude, zoom, pitch, bearing } = viewport;
    return {
        width,
        height,
        longitude,
        latitude,
        zoom,
        pitch,
        bearing,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmxvd21hcExheWVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL0Zsb3dtYXBMYXllci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7OztHQUlHO0FBQ0gsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUM3QyxPQUFPLEVBQUMsZ0JBQWdCLEVBQUUsU0FBUyxFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFDNUQsT0FBTyxFQUdMLHlCQUF5QixFQUt6Qix3QkFBd0IsRUFFeEIsV0FBVyxFQUNYLDRCQUE0QixFQUM1QixnQkFBZ0IsRUFDaEIsd0JBQXdCLEVBQ3hCLDJCQUEyQixFQUMzQixhQUFhLEVBQ2IscUJBQXFCLEdBQ3RCLE1BQU0sa0JBQWtCLENBQUM7QUFDMUIsT0FBTyxzQkFBc0IsTUFBTSwwQkFBMEIsQ0FBQztBQUM5RCxPQUFPLGdCQUFnQixNQUFNLG9CQUFvQixDQUFDO0FBQ2xELE9BQU8sY0FBYyxNQUFNLGtCQUFrQixDQUFDO0FBQzlDLE9BQU8sRUFJTCxXQUFXLEdBQ1osTUFBTSxTQUFTLENBQUM7QUFnQ2pCLE1BQU0sZ0NBQWdDLEdBQWE7SUFDakQsUUFBUTtJQUNSLGtCQUFrQjtJQUNsQix1QkFBdUI7SUFDdkIsdUJBQXVCO0lBQ3ZCLHVCQUF1QjtJQUN2QixrQkFBa0I7SUFDbEIsbUJBQW1CO0lBQ25CLGlCQUFpQjtJQUNqQixhQUFhO0lBQ2Isb0JBQW9CO0lBQ3BCLGdCQUFnQjtJQUNoQixVQUFVO0lBQ1YsWUFBWTtJQUNaLGFBQWE7SUFDYixnQkFBZ0I7SUFDaEIsdUJBQXVCO0NBQ3hCLENBQUM7QUFFRixJQUFLLGFBR0o7QUFIRCxXQUFLLGFBQWE7SUFDaEIsc0NBQXFCLENBQUE7SUFDckIsOEJBQWEsQ0FBQTtBQUNmLENBQUMsRUFISSxhQUFhLEtBQWIsYUFBYSxRQUdqQjtBQTJCRCxNQUFxQixZQUduQixTQUFRLGNBQWM7SUFvQnRCLFlBQW1CLEtBQThCO1FBQy9DLEtBQUssQ0FB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LENBQUMsQ0FDSCxDQUNGLENBQUM7YUFDSDtTQUNGO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQzs7QUFoY00seUJBQVksR0FBRztJQUNwQixRQUFRLEVBQUUsSUFBSTtJQUNkLFVBQVUsRUFBRSxFQUFFO0lBQ2QsZ0JBQWdCLEVBQUUsSUFBSTtJQUN0QixxQkFBcUIsRUFBRSxJQUFJO0lBQzNCLHFCQUFxQixFQUFFLEtBQUs7SUFDNUIsZ0JBQWdCLEVBQUUsS0FBSztJQUN2QixpQkFBaUIsRUFBRSxJQUFJO0lBQ3ZCLFdBQVcsRUFBRSxJQUFJO0lBQ2pCLGtCQUFrQixFQUFFLEtBQUs7SUFDekIsY0FBYyxFQUFFLElBQUk7SUFDcEIsZUFBZSxFQUFFLFNBQVM7SUFDMUIscUJBQXFCLEVBQUUsSUFBSTtJQUMzQixXQUFXLEVBQUUsTUFBTTtJQUNuQixjQUFjLEVBQUUsUUFBUTtJQUN4QixxQkFBcUIsRUFBRSxJQUFJO0NBQzVCLENBQUM7ZUFwQmlCLFlBQVk7QUF1Y2pDLFNBQVMsaUJBQWlCLENBQUMsUUFBNkI7SUFDdEQsTUFBTSxFQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBQyxHQUFHLFFBQVEsQ0FBQztJQUM1RSxPQUFPO1FBQ0wsS0FBSztRQUNMLE1BQU07UUFDTixTQUFTO1FBQ1QsUUFBUTtRQUNSLElBQUk7UUFDSixLQUFLO1FBQ0wsT0FBTztLQUNSLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgRmxvd21hcC5nbCBjb250cmlidXRvcnNcbiAqIENvcHlyaWdodCAoYykgMjAxOC0yMDIwIFRlcmFseXRpY3NcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmltcG9ydCB7Q29tcG9zaXRlTGF5ZXJ9IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuaW1wb3J0IHtTY2F0dGVycGxvdExheWVyLCBUZXh0TGF5ZXJ9IGZyb20gJ0BkZWNrLmdsL2xheWVycyc7XG5pbXBvcnQge1xuICBGaWx0ZXJTdGF0ZSxcbiAgRmxvd0xpbmVzTGF5ZXJBdHRyaWJ1dGVzLFxuICBGbG93bWFwQWdncmVnYXRlQWNjZXNzb3JzLFxuICBGbG93bWFwRGF0YSxcbiAgRmxvd21hcERhdGFBY2Nlc3NvcnMsXG4gIEZsb3dtYXBEYXRhUHJvdmlkZXIsXG4gIExheWVyc0RhdGEsXG4gIExvY2FsRmxvd21hcERhdGFQcm92aWRlcixcbiAgVmlld3BvcnRQcm9wcyxcbiAgY29sb3JBc1JnYmEsXG4gIGdldEZsb3dMaW5lQXR0cmlidXRlc0J5SW5kZXgsXG4gIGdldEZsb3dtYXBDb2xvcnMsXG4gIGdldExvY2F0aW9uQ29vcmRzQnlJbmRleCxcbiAgZ2V0T3V0ZXJDaXJjbGVSYWRpdXNCeUluZGV4LFxuICBpc0Zsb3dtYXBEYXRhLFxuICBpc0Zsb3dtYXBEYXRhUHJvdmlkZXIsXG59IGZyb20gJ0BmbG93bWFwLmdsL2RhdGEnO1xuaW1wb3J0IEFuaW1hdGVkRmxvd0xpbmVzTGF5ZXIgZnJvbSAnLi9BbmltYXRlZEZsb3dMaW5lc0xheWVyJztcbmltcG9ydCBGbG93Q2lyY2xlc0xheWVyIGZyb20gJy4vRmxvd0NpcmNsZXNMYXllcic7XG5pbXBvcnQgRmxvd0xpbmVzTGF5ZXIgZnJvbSAnLi9GbG93TGluZXNMYXllcic7XG5pbXBvcnQge1xuICBGbG93bWFwTGF5ZXJQaWNraW5nSW5mbyxcbiAgTGF5ZXJQcm9wcyxcbiAgUGlja2luZ0luZm8sXG4gIFBpY2tpbmdUeXBlLFxufSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgRmxvd21hcExheWVyUHJvcHM8XG4gIEwgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBGIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pixcbj4gPSB7XG4gIGRhdGE/OiBGbG93bWFwRGF0YTxMLCBGPjtcbiAgZGF0YVByb3ZpZGVyPzogRmxvd21hcERhdGFQcm92aWRlcjxMLCBGPjtcbiAgZmlsdGVyPzogRmlsdGVyU3RhdGU7XG4gIGxvY2F0aW9uc0VuYWJsZWQ/OiBib29sZWFuO1xuICBsb2NhdGlvblRvdGFsc0VuYWJsZWQ/OiBib29sZWFuO1xuICBsb2NhdGlvbkxhYmVsc0VuYWJsZWQ/OiBib29sZWFuO1xuICBhZGFwdGl2ZVNjYWxlc0VuYWJsZWQ/OiBib29sZWFuO1xuICBhbmltYXRpb25FbmFibGVkPzogYm9vbGVhbjtcbiAgY2x1c3RlcmluZ0VuYWJsZWQ/OiBib29sZWFuO1xuICBjbHVzdGVyaW5nTGV2ZWw/OiBudW1iZXI7XG4gIGZhZGVFbmFibGVkPzogYm9vbGVhbjtcbiAgZmFkZU9wYWNpdHlFbmFibGVkPzogYm9vbGVhbjtcbiAgY2x1c3RlcmluZ0F1dG8/OiBib29sZWFuO1xuICBkYXJrTW9kZT86IGJvb2xlYW47XG4gIGZhZGVBbW91bnQ/OiBudW1iZXI7XG4gIGNvbG9yU2NoZW1lPzogc3RyaW5nIHwgc3RyaW5nW107XG4gIGhpZ2hsaWdodENvbG9yPzogc3RyaW5nIHwgbnVtYmVyW107XG4gIG1heFRvcEZsb3dzRGlzcGxheU51bT86IG51bWJlcjtcbiAgb25Ib3Zlcj86IChcbiAgICBpbmZvOiBGbG93bWFwTGF5ZXJQaWNraW5nSW5mbzxMLCBGPiB8IHVuZGVmaW5lZCxcbiAgICBldmVudDogU291cmNlRXZlbnQsXG4gICkgPT4gdm9pZDtcbiAgb25DbGljaz86IChpbmZvOiBGbG93bWFwTGF5ZXJQaWNraW5nSW5mbzxMLCBGPiwgZXZlbnQ6IFNvdXJjZUV2ZW50KSA9PiB2b2lkO1xufSAmIFBhcnRpYWw8Rmxvd21hcERhdGFBY2Nlc3NvcnM8TCwgRj4+ICZcbiAgTGF5ZXJQcm9wcztcblxuY29uc3QgUFJPUFNfVE9fQ0FVU0VfTEFZRVJfREFUQV9VUERBVEU6IHN0cmluZ1tdID0gW1xuICAnZmlsdGVyJyxcbiAgJ2xvY2F0aW9uc0VuYWJsZWQnLFxuICAnbG9jYXRpb25Ub3RhbHNFbmFibGVkJyxcbiAgJ2xvY2F0aW9uTGFiZWxzRW5hYmxlZCcsXG4gICdhZGFwdGl2ZVNjYWxlc0VuYWJsZWQnLFxuICAnYW5pbWF0aW9uRW5hYmxlZCcsXG4gICdjbHVzdGVyaW5nRW5hYmxlZCcsXG4gICdjbHVzdGVyaW5nTGV2ZWwnLFxuICAnZmFkZUVuYWJsZWQnLFxuICAnZmFkZU9wYWNpdHlFbmFibGVkJyxcbiAgJ2NsdXN0ZXJpbmdBdXRvJyxcbiAgJ2RhcmtNb2RlJyxcbiAgJ2ZhZGVBbW91bnQnLFxuICAnY29sb3JTY2hlbWUnLFxuICAnaGlnaGxpZ2h0Q29sb3InLFxuICAnbWF4VG9wRmxvd3NEaXNwbGF5TnVtJyxcbl07XG5cbmVudW0gSGlnaGxpZ2h0VHlwZSB7XG4gIExPQ0FUSU9OID0gJ2xvY2F0aW9uJyxcbiAgRkxPVyA9ICdmbG93Jyxcbn1cblxudHlwZSBIaWdobGlnaHRlZExvY2F0aW9uT2JqZWN0ID0ge1xuICB0eXBlOiBIaWdobGlnaHRUeXBlLkxPQ0FUSU9OO1xuICBjb29yZHM6IFtudW1iZXIsIG51bWJlcl07XG4gIHJhZGl1czogbnVtYmVyO1xufTtcblxudHlwZSBIaWdobGlnaHRlZEZsb3dPYmplY3QgPSB7XG4gIHR5cGU6IEhpZ2hsaWdodFR5cGUuRkxPVztcbiAgbGluZUF0dHJpYnV0ZXM6IEZsb3dMaW5lc0xheWVyQXR0cmlidXRlcztcbn07XG5cbnR5cGUgSGlnaGxpZ2h0ZWRPYmplY3QgPSBIaWdobGlnaHRlZExvY2F0aW9uT2JqZWN0IHwgSGlnaGxpZ2h0ZWRGbG93T2JqZWN0O1xuXG50eXBlIFN0YXRlPEwgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBGIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4gPSB7XG4gIGFjY2Vzc29yczogRmxvd21hcEFnZ3JlZ2F0ZUFjY2Vzc29yczxMLCBGPjtcbiAgZGF0YVByb3ZpZGVyOiBGbG93bWFwRGF0YVByb3ZpZGVyPEwsIEY+O1xuICBsYXllcnNEYXRhOiBMYXllcnNEYXRhIHwgdW5kZWZpbmVkO1xuICBoaWdobGlnaHRlZE9iamVjdDogSGlnaGxpZ2h0ZWRPYmplY3QgfCB1bmRlZmluZWQ7XG4gIHBpY2tpbmdJbmZvOiBGbG93bWFwTGF5ZXJQaWNraW5nSW5mbzxMLCBGPiB8IHVuZGVmaW5lZDtcbiAgbGFzdEhvdmVyVGltZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICBsYXN0Q2xpY2tUaW1lOiBudW1iZXIgfCB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgdHlwZSBTb3VyY2VFdmVudCA9IHtzcmNFdmVudDogTW91c2VFdmVudH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZsb3dtYXBMYXllcjxcbiAgTCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIEYgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuPiBleHRlbmRzIENvbXBvc2l0ZUxheWVyIHtcbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBkYXJrTW9kZTogdHJ1ZSxcbiAgICBmYWRlQW1vdW50OiA1MCxcbiAgICBsb2NhdGlvbnNFbmFibGVkOiB0cnVlLFxuICAgIGxvY2F0aW9uVG90YWxzRW5hYmxlZDogdHJ1ZSxcbiAgICBsb2NhdGlvbkxhYmVsc0VuYWJsZWQ6IGZhbHNlLFxuICAgIGFuaW1hdGlvbkVuYWJsZWQ6IGZhbHNlLFxuICAgIGNsdXN0ZXJpbmdFbmFibGVkOiB0cnVlLFxuICAgIGZhZGVFbmFibGVkOiB0cnVlLFxuICAgIGZhZGVPcGFjaXR5RW5hYmxlZDogZmFsc2UsXG4gICAgY2x1c3RlcmluZ0F1dG86IHRydWUsXG4gICAgY2x1c3RlcmluZ0xldmVsOiB1bmRlZmluZWQsXG4gICAgYWRhcHRpdmVTY2FsZXNFbmFibGVkOiB0cnVlLFxuICAgIGNvbG9yU2NoZW1lOiAnVGVhbCcsXG4gICAgaGlnaGxpZ2h0Q29sb3I6ICdvcmFuZ2UnLFxuICAgIG1heFRvcEZsb3dzRGlzcGxheU51bTogNTAwMCxcbiAgfTtcbiAgc3RhdGU6IFN0YXRlPEwsIEY+IHwgdW5kZWZpbmVkO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcm9wczogRmxvd21hcExheWVyUHJvcHM8TCwgRj4pIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIG9uSG92ZXI6IChpbmZvOiBQaWNraW5nSW5mbzxhbnk+LCBldmVudDogU291cmNlRXZlbnQpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgaGlnaGxpZ2h0ZWRPYmplY3Q6IHRoaXMuX2dldEhpZ2hsaWdodGVkT2JqZWN0KGluZm8pLFxuICAgICAgICAgIGxhc3RIb3ZlclRpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qge29uSG92ZXJ9ID0gcHJvcHM7XG4gICAgICAgIGlmIChvbkhvdmVyKSB7XG4gICAgICAgICAgdGhpcy5fZ2V0Rmxvd21hcExheWVyUGlja2luZ0luZm8oaW5mbykudGhlbigoaW5mbykgPT4ge1xuICAgICAgICAgICAgaWYgKCh0aGlzLnN0YXRlPy5sYXN0SG92ZXJUaW1lID8/IDApIDw9IHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtwaWNraW5nSW5mbzogaW5mb30pO1xuICAgICAgICAgICAgICBvbkhvdmVyKGluZm8sIGV2ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFNraXBwaW5nLCBiZWNhdXNlIHRoaXMgaXMgbm90IHRoZSBsYXRlc3QgaG92ZXIgZXZlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2xpY2s6IChpbmZvOiBQaWNraW5nSW5mbzxhbnk+LCBldmVudDogU291cmNlRXZlbnQpID0+IHtcbiAgICAgICAgY29uc3Qge29uQ2xpY2t9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGxhc3RDbGlja1RpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgdGhpcy5fZ2V0Rmxvd21hcExheWVyUGlja2luZ0luZm8oaW5mbykudGhlbigoaW5mbykgPT4ge1xuICAgICAgICAgICAgaWYgKCh0aGlzLnN0YXRlPy5sYXN0Q2xpY2tUaW1lID8/IDApIDw9IHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtwaWNraW5nSW5mbzogaW5mb30pO1xuICAgICAgICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgICAgIG9uQ2xpY2soaW5mbywgZXZlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBTa2lwcGluZywgYmVjYXVzZSB0aGlzIGlzIG5vdCB0aGUgbGF0ZXN0IGhvdmVyIGV2ZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGFjY2Vzc29yczogbmV3IEZsb3dtYXBBZ2dyZWdhdGVBY2Nlc3NvcnM8TCwgRj4odGhpcy5wcm9wcyksXG4gICAgICBkYXRhUHJvdmlkZXI6IHRoaXMuX2dldE9yTWFrZURhdGFQcm92aWRlcigpLFxuICAgICAgbGF5ZXJzRGF0YTogdW5kZWZpbmVkLFxuICAgICAgaGlnaGxpZ2h0ZWRPYmplY3Q6IHVuZGVmaW5lZCxcbiAgICAgIHBpY2tpbmdJbmZvOiB1bmRlZmluZWQsXG4gICAgICBsYXN0SG92ZXJUaW1lOiB1bmRlZmluZWQsXG4gICAgICBsYXN0Q2xpY2tUaW1lOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfVxuXG4gIGdldFBpY2tpbmdJbmZvKHtpbmZvfTogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIC8vIFRoaXMgaXMgZm9yIG9uSG92ZXIgZXZlbnQgaGFuZGxlcnMgc2V0IG9uIHRoZSA8RGVja0dMPiBjb21wb25lbnRcbiAgICBpZiAoIWluZm8ub2JqZWN0KSB7XG4gICAgICBjb25zdCBvYmplY3QgPSB0aGlzLnN0YXRlPy5waWNraW5nSW5mbz8ub2JqZWN0O1xuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmluZm8sXG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgIHBpY2tlZDogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICAvLyBwcml2YXRlIF91cGRhdGVBY2Nlc3NvcnMoKSB7XG4gIC8vICAgdGhpcy5zdGF0ZT8uZGF0YVByb3ZpZGVyPy5zZXRBY2Nlc3NvcnModGhpcy5wcm9wcyk7XG4gIC8vICAgdGhpcy5zZXRTdGF0ZSh7YWNjZXNzb3JzOiBuZXcgRmxvd21hcEFnZ3JlZ2F0ZUFjY2Vzc29ycyh0aGlzLnByb3BzKX0pO1xuICAvLyB9XG5cbiAgcHJpdmF0ZSBfZ2V0T3JNYWtlRGF0YVByb3ZpZGVyKCkge1xuICAgIGNvbnN0IHtkYXRhLCBkYXRhUHJvdmlkZXJ9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoaXNGbG93bWFwRGF0YVByb3ZpZGVyPEwsIEY+KGRhdGFQcm92aWRlcikpIHtcbiAgICAgIHJldHVybiBkYXRhUHJvdmlkZXI7XG4gICAgfSBlbHNlIGlmIChpc0Zsb3dtYXBEYXRhPEwsIEY+KGRhdGEpKSB7XG4gICAgICBjb25zdCBkYXRhUHJvdmlkZXIgPSBuZXcgTG9jYWxGbG93bWFwRGF0YVByb3ZpZGVyPEwsIEY+KHRoaXMucHJvcHMpO1xuICAgICAgZGF0YVByb3ZpZGVyLnNldEZsb3dtYXBEYXRhKGRhdGEpO1xuICAgICAgcmV0dXJuIGRhdGFQcm92aWRlcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0Zsb3dtYXBMYXllcjogZGF0YSBtdXN0IGJlIGEgRmxvd21hcERhdGFQcm92aWRlciBvciBGbG93bWFwRGF0YScsXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgX3VwZGF0ZURhdGFQcm92aWRlcigpIHtcbiAgICB0aGlzLnNldFN0YXRlKHtkYXRhUHJvdmlkZXI6IHRoaXMuX2dldE9yTWFrZURhdGFQcm92aWRlcigpfSk7XG4gIH1cblxuICBzaG91bGRVcGRhdGVTdGF0ZShwYXJhbXM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBib29sZWFuIHtcbiAgICBjb25zdCB7Y2hhbmdlRmxhZ3N9ID0gcGFyYW1zO1xuICAgIC8vIGlmICh0aGlzLl92aWV3cG9ydENoYW5nZWQoKSkge1xuICAgIC8vICAgcmV0dXJuIHRydWU7XG4gICAgLy8gfVxuICAgIGlmIChjaGFuZ2VGbGFncy52aWV3cG9ydENoYW5nZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuc2hvdWxkVXBkYXRlU3RhdGUocGFyYW1zKTtcbiAgICAvLyBUT0RPOiBiZSBzbWFydGVyIG9uIHdoZW4gdG8gdXBkYXRlXG4gICAgLy8gKGUuZy4gaWdub3JlIHZpZXdwb3J0IGNoYW5nZXMgd2hlbiBhZGFwdGl2ZVNjYWxlc0VuYWJsZWQgYW5kIGNsdXN0ZXJpbmcgYXJlIGZhbHNlKVxuICB9XG5cbiAgdXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgY2hhbmdlRmxhZ3N9OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG4gICAgaWYgKGNoYW5nZUZsYWdzLnByb3BzQ2hhbmdlZCkge1xuICAgICAgLy8gdGhpcy5fdXBkYXRlQWNjZXNzb3JzKCk7XG4gICAgfVxuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fdXBkYXRlRGF0YVByb3ZpZGVyKCk7XG4gICAgfVxuICAgIGlmIChjaGFuZ2VGbGFncy52aWV3cG9ydENoYW5nZWQgfHwgY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe2hpZ2hsaWdodGVkT2JqZWN0OiB1bmRlZmluZWR9KTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBjaGFuZ2VGbGFncy52aWV3cG9ydENoYW5nZWQgfHxcbiAgICAgIGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkIHx8XG4gICAgICAoY2hhbmdlRmxhZ3MucHJvcHNDaGFuZ2VkICYmXG4gICAgICAgIFBST1BTX1RPX0NBVVNFX0xBWUVSX0RBVEFfVVBEQVRFLnNvbWUoXG4gICAgICAgICAgKHByb3ApID0+IG9sZFByb3BzW3Byb3BdICE9PSBwcm9wc1twcm9wXSxcbiAgICAgICAgKSlcbiAgICApIHtcbiAgICAgIGNvbnN0IHtkYXRhUHJvdmlkZXJ9ID0gdGhpcy5zdGF0ZSB8fCB7fTtcbiAgICAgIGlmIChkYXRhUHJvdmlkZXIpIHtcbiAgICAgICAgZGF0YVByb3ZpZGVyLnNldEZsb3dtYXBTdGF0ZSh0aGlzLl9nZXRGbG93bWFwU3RhdGUoKSk7XG4gICAgICAgIGRhdGFQcm92aWRlci51cGRhdGVMYXllcnNEYXRhKChsYXllcnNEYXRhOiBMYXllcnNEYXRhIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7bGF5ZXJzRGF0YSwgaGlnaGxpZ2h0ZWRPYmplY3Q6IHVuZGVmaW5lZH0pO1xuICAgICAgICB9LCBjaGFuZ2VGbGFncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0U2V0dGluZ3NTdGF0ZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBsb2NhdGlvbnNFbmFibGVkLFxuICAgICAgbG9jYXRpb25Ub3RhbHNFbmFibGVkLFxuICAgICAgbG9jYXRpb25MYWJlbHNFbmFibGVkLFxuICAgICAgYWRhcHRpdmVTY2FsZXNFbmFibGVkLFxuICAgICAgYW5pbWF0aW9uRW5hYmxlZCxcbiAgICAgIGNsdXN0ZXJpbmdFbmFibGVkLFxuICAgICAgY2x1c3RlcmluZ0xldmVsLFxuICAgICAgZmFkZUVuYWJsZWQsXG4gICAgICBmYWRlT3BhY2l0eUVuYWJsZWQsXG4gICAgICBjbHVzdGVyaW5nQXV0byxcbiAgICAgIGRhcmtNb2RlLFxuICAgICAgZmFkZUFtb3VudCxcbiAgICAgIGNvbG9yU2NoZW1lLFxuICAgICAgaGlnaGxpZ2h0Q29sb3IsXG4gICAgICBtYXhUb3BGbG93c0Rpc3BsYXlOdW0sXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvY2F0aW9uc0VuYWJsZWQsXG4gICAgICBsb2NhdGlvblRvdGFsc0VuYWJsZWQsXG4gICAgICBsb2NhdGlvbkxhYmVsc0VuYWJsZWQsXG4gICAgICBhZGFwdGl2ZVNjYWxlc0VuYWJsZWQsXG4gICAgICBhbmltYXRpb25FbmFibGVkLFxuICAgICAgY2x1c3RlcmluZ0VuYWJsZWQsXG4gICAgICBjbHVzdGVyaW5nTGV2ZWwsXG4gICAgICBmYWRlRW5hYmxlZCxcbiAgICAgIGZhZGVPcGFjaXR5RW5hYmxlZCxcbiAgICAgIGNsdXN0ZXJpbmdBdXRvLFxuICAgICAgZGFya01vZGUsXG4gICAgICBmYWRlQW1vdW50LFxuICAgICAgY29sb3JTY2hlbWUsXG4gICAgICBoaWdobGlnaHRDb2xvcixcbiAgICAgIG1heFRvcEZsb3dzRGlzcGxheU51bSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0Rmxvd21hcFN0YXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICB2aWV3cG9ydDogcGlja1ZpZXdwb3J0UHJvcHModGhpcy5jb250ZXh0LnZpZXdwb3J0KSxcbiAgICAgIGZpbHRlcjogdGhpcy5wcm9wcy5maWx0ZXIsXG4gICAgICBzZXR0aW5nczogdGhpcy5fZ2V0U2V0dGluZ3NTdGF0ZSgpLFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9nZXRGbG93bWFwTGF5ZXJQaWNraW5nSW5mbyhcbiAgICBpbmZvOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICApOiBQcm9taXNlPEZsb3dtYXBMYXllclBpY2tpbmdJbmZvPEwsIEY+IHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3Qge2luZGV4LCBzb3VyY2VMYXllcn0gPSBpbmZvO1xuICAgIGNvbnN0IHtkYXRhUHJvdmlkZXIsIGFjY2Vzc29yc30gPSB0aGlzLnN0YXRlIHx8IHt9O1xuICAgIGlmICghZGF0YVByb3ZpZGVyIHx8ICFhY2Nlc3NvcnMpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGNvbW1vbkluZm8gPSB7XG4gICAgICAuLi5pbmZvLFxuICAgICAgcGlja2VkOiBpbmZvLnBpY2tlZCxcbiAgICAgIGxheWVyOiBpbmZvLmxheWVyLFxuICAgICAgaW5kZXg6IGluZm8uaW5kZXgsXG4gICAgICB4OiBpbmZvLngsXG4gICAgICB5OiBpbmZvLnksXG4gICAgICBjb29yZGluYXRlOiBpbmZvLmNvb3JkaW5hdGUsXG4gICAgICBldmVudDogaW5mby5ldmVudCxcbiAgICB9O1xuICAgIGlmIChcbiAgICAgIHNvdXJjZUxheWVyIGluc3RhbmNlb2YgRmxvd0xpbmVzTGF5ZXIgfHxcbiAgICAgIHNvdXJjZUxheWVyIGluc3RhbmNlb2YgQW5pbWF0ZWRGbG93TGluZXNMYXllclxuICAgICkge1xuICAgICAgY29uc3QgZmxvdyA9XG4gICAgICAgIGluZGV4ID09PSAtMSA/IHVuZGVmaW5lZCA6IGF3YWl0IGRhdGFQcm92aWRlci5nZXRGbG93QnlJbmRleChpbmRleCk7XG4gICAgICBpZiAoZmxvdykge1xuICAgICAgICBjb25zdCBvcmlnaW4gPSBhd2FpdCBkYXRhUHJvdmlkZXIuZ2V0TG9jYXRpb25CeUlkKFxuICAgICAgICAgIGFjY2Vzc29ycy5nZXRGbG93T3JpZ2luSWQoZmxvdyksXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGRlc3QgPSBhd2FpdCBkYXRhUHJvdmlkZXIuZ2V0TG9jYXRpb25CeUlkKFxuICAgICAgICAgIGFjY2Vzc29ycy5nZXRGbG93RGVzdElkKGZsb3cpLFxuICAgICAgICApO1xuICAgICAgICBpZiAob3JpZ2luICYmIGRlc3QpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbW9uSW5mbyxcbiAgICAgICAgICAgIG9iamVjdDoge1xuICAgICAgICAgICAgICB0eXBlOiBQaWNraW5nVHlwZS5GTE9XLFxuICAgICAgICAgICAgICBmbG93LFxuICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbixcbiAgICAgICAgICAgICAgZGVzdDogZGVzdCxcbiAgICAgICAgICAgICAgY291bnQ6IGFjY2Vzc29ycy5nZXRGbG93TWFnbml0dWRlKGZsb3cpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzb3VyY2VMYXllciBpbnN0YW5jZW9mIEZsb3dDaXJjbGVzTGF5ZXIpIHtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID1cbiAgICAgICAgaW5kZXggPT09IC0xID8gdW5kZWZpbmVkIDogYXdhaXQgZGF0YVByb3ZpZGVyLmdldExvY2F0aW9uQnlJbmRleChpbmRleCk7XG5cbiAgICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgICBjb25zdCBpZCA9IGFjY2Vzc29ycy5nZXRMb2NhdGlvbklkKGxvY2F0aW9uKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGFjY2Vzc29ycy5nZXRMb2NhdGlvbk5hbWUobG9jYXRpb24pO1xuICAgICAgICBjb25zdCB0b3RhbHMgPSBhd2FpdCBkYXRhUHJvdmlkZXIuZ2V0VG90YWxzRm9yTG9jYXRpb24oaWQpO1xuICAgICAgICBjb25zdCB7Y2lyY2xlQXR0cmlidXRlc30gPSB0aGlzLnN0YXRlPy5sYXllcnNEYXRhIHx8IHt9O1xuICAgICAgICBpZiAodG90YWxzICYmIGNpcmNsZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBjb25zdCBjaXJjbGVSYWRpdXMgPSBnZXRPdXRlckNpcmNsZVJhZGl1c0J5SW5kZXgoXG4gICAgICAgICAgICBjaXJjbGVBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgaW5mby5pbmRleCxcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb21tb25JbmZvLFxuICAgICAgICAgICAgb2JqZWN0OiB7XG4gICAgICAgICAgICAgIHR5cGU6IFBpY2tpbmdUeXBlLkxPQ0FUSU9OLFxuICAgICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIHRvdGFscyxcbiAgICAgICAgICAgICAgY2lyY2xlUmFkaXVzOiBjaXJjbGVSYWRpdXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0SGlnaGxpZ2h0ZWRPYmplY3QoXG4gICAgaW5mbzogUmVjb3JkPHN0cmluZywgYW55PixcbiAgKTogSGlnaGxpZ2h0ZWRPYmplY3QgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHtpbmRleCwgc291cmNlTGF5ZXJ9ID0gaW5mbztcbiAgICBpZiAoaW5kZXggPCAwKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmIChcbiAgICAgIHNvdXJjZUxheWVyIGluc3RhbmNlb2YgRmxvd0xpbmVzTGF5ZXIgfHxcbiAgICAgIHNvdXJjZUxheWVyIGluc3RhbmNlb2YgQW5pbWF0ZWRGbG93TGluZXNMYXllclxuICAgICkge1xuICAgICAgY29uc3Qge2xpbmVBdHRyaWJ1dGVzfSA9IHRoaXMuc3RhdGU/LmxheWVyc0RhdGEgfHwge307XG4gICAgICBpZiAobGluZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgbGV0IGF0dHJzID0gZ2V0Rmxvd0xpbmVBdHRyaWJ1dGVzQnlJbmRleChsaW5lQXR0cmlidXRlcywgaW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5mYWRlT3BhY2l0eUVuYWJsZWQpIHtcbiAgICAgICAgICBhdHRycyA9IHtcbiAgICAgICAgICAgIC4uLmF0dHJzLFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAuLi5hdHRycy5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICBnZXRDb2xvcjoge1xuICAgICAgICAgICAgICAgIC4uLmF0dHJzLmF0dHJpYnV0ZXMuZ2V0Q29sb3IsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgICAgICAgIC4uLmF0dHJzLmF0dHJpYnV0ZXMuZ2V0Q29sb3IudmFsdWUuc2xpY2UoMCwgMyksXG4gICAgICAgICAgICAgICAgICAyNTUsIC8vIHRoZSBoaWdobGlnaHQgY29sb3Igc2hvdWxkIGJlIGFsd2F5cyBvcGFxdWVcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IEhpZ2hsaWdodFR5cGUuRkxPVyxcbiAgICAgICAgICBsaW5lQXR0cmlidXRlczogYXR0cnMsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzb3VyY2VMYXllciBpbnN0YW5jZW9mIEZsb3dDaXJjbGVzTGF5ZXIpIHtcbiAgICAgIGNvbnN0IHtjaXJjbGVBdHRyaWJ1dGVzfSA9IHRoaXMuc3RhdGU/LmxheWVyc0RhdGEgfHwge307XG4gICAgICBpZiAoY2lyY2xlQXR0cmlidXRlcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IEhpZ2hsaWdodFR5cGUuTE9DQVRJT04sXG4gICAgICAgICAgY29vcmRzOiBnZXRMb2NhdGlvbkNvb3Jkc0J5SW5kZXgoY2lyY2xlQXR0cmlidXRlcywgaW5kZXgpLFxuICAgICAgICAgIHJhZGl1czogZ2V0T3V0ZXJDaXJjbGVSYWRpdXNCeUluZGV4KGNpcmNsZUF0dHJpYnV0ZXMsIGluZGV4KSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJlbmRlckxheWVycygpOiBBcnJheTxhbnk+IHtcbiAgICBjb25zdCBsYXllcnMgPSBbXTtcbiAgICBpZiAodGhpcy5zdGF0ZT8ubGF5ZXJzRGF0YSkge1xuICAgICAgY29uc3Qge2xheWVyc0RhdGEsIGhpZ2hsaWdodGVkT2JqZWN0fSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCB7Y2lyY2xlQXR0cmlidXRlcywgbGluZUF0dHJpYnV0ZXMsIGxvY2F0aW9uTGFiZWxzfSA9XG4gICAgICAgIGxheWVyc0RhdGEgfHwge307XG4gICAgICBpZiAoY2lyY2xlQXR0cmlidXRlcyAmJiBsaW5lQXR0cmlidXRlcykge1xuICAgICAgICBjb25zdCBmbG93bWFwQ29sb3JzID0gZ2V0Rmxvd21hcENvbG9ycyh0aGlzLl9nZXRTZXR0aW5nc1N0YXRlKCkpO1xuICAgICAgICBjb25zdCBvdXRsaW5lQ29sb3IgPSBjb2xvckFzUmdiYShcbiAgICAgICAgICBmbG93bWFwQ29sb3JzLm91dGxpbmVDb2xvciB8fCAodGhpcy5wcm9wcy5kYXJrTW9kZSA/ICcjMDAwJyA6ICcjZmZmJyksXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGNvbW1vbkxpbmVMYXllclByb3BzID0ge1xuICAgICAgICAgIGRhdGE6IGxpbmVBdHRyaWJ1dGVzLFxuICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIC4uLnRoaXMucHJvcHMucGFyYW1ldGVycyxcbiAgICAgICAgICAgIC8vIHByZXZlbnQgei1maWdodGluZyBhdCBub24temVybyBiZWFyaW5nL3BpdGNoXG4gICAgICAgICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmFuaW1hdGlvbkVuYWJsZWQpIHtcbiAgICAgICAgICBsYXllcnMucHVzaChcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIG5ldyBBbmltYXRlZEZsb3dMaW5lc0xheWVyKHtcbiAgICAgICAgICAgICAgLi4udGhpcy5nZXRTdWJMYXllclByb3BzKHtcbiAgICAgICAgICAgICAgICAuLi5jb21tb25MaW5lTGF5ZXJQcm9wcyxcbiAgICAgICAgICAgICAgICBpZDogJ2FuaW1hdGVkLWZsb3ctbGluZXMnLFxuICAgICAgICAgICAgICAgIGRyYXdPdXRsaW5lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0aGlja25lc3NVbml0OiAyMCxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxheWVycy5wdXNoKFxuICAgICAgICAgICAgbmV3IEZsb3dMaW5lc0xheWVyKHtcbiAgICAgICAgICAgICAgLi4udGhpcy5nZXRTdWJMYXllclByb3BzKHtcbiAgICAgICAgICAgICAgICAuLi5jb21tb25MaW5lTGF5ZXJQcm9wcyxcbiAgICAgICAgICAgICAgICBpZDogJ2Zsb3ctbGluZXMnLFxuICAgICAgICAgICAgICAgIGRyYXdPdXRsaW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgIG91dGxpbmVDb2xvcjogb3V0bGluZUNvbG9yLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGF5ZXJzLnB1c2goXG4gICAgICAgICAgbmV3IEZsb3dDaXJjbGVzTGF5ZXIoXG4gICAgICAgICAgICB0aGlzLmdldFN1YkxheWVyUHJvcHMoe1xuICAgICAgICAgICAgICBpZDogJ2NpcmNsZXMnLFxuICAgICAgICAgICAgICBkYXRhOiBjaXJjbGVBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICBlbXB0eUNvbG9yOiB0aGlzLnByb3BzLmRhcmtNb2RlXG4gICAgICAgICAgICAgICAgPyBbMCwgMCwgMCwgMjU1XVxuICAgICAgICAgICAgICAgIDogWzI1NSwgMjU1LCAyNTUsIDI1NV0sXG4gICAgICAgICAgICAgIG91dGxpbmVFbXB0eU1peDogMC40LFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGhpZ2hsaWdodGVkT2JqZWN0KSB7XG4gICAgICAgICAgc3dpdGNoIChoaWdobGlnaHRlZE9iamVjdC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEhpZ2hsaWdodFR5cGUuTE9DQVRJT046XG4gICAgICAgICAgICAgIGxheWVycy5wdXNoKFxuICAgICAgICAgICAgICAgIG5ldyBTY2F0dGVycGxvdExheWVyKHtcbiAgICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2V0U3ViTGF5ZXJQcm9wcyh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnbG9jYXRpb24taGlnaGxpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogW2hpZ2hsaWdodGVkT2JqZWN0XSxcbiAgICAgICAgICAgICAgICAgICAgcGlja2FibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhbnRpYWxpYXNpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGZpbGxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aFVuaXRzOiAncGl4ZWxzJyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0TGluZVdpZHRoOiAyLFxuICAgICAgICAgICAgICAgICAgICByYWRpdXNVbml0czogJ3BpeGVscycsXG4gICAgICAgICAgICAgICAgICAgIGdldFJhZGl1czogKGQ6IEhpZ2hsaWdodGVkTG9jYXRpb25PYmplY3QpID0+IGQucmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICBnZXRMaW5lQ29sb3I6IGNvbG9yQXNSZ2JhKHRoaXMucHJvcHMuaGlnaGxpZ2h0Q29sb3IpLFxuICAgICAgICAgICAgICAgICAgICBnZXRQb3NpdGlvbjogKGQ6IEhpZ2hsaWdodGVkTG9jYXRpb25PYmplY3QpID0+IGQuY29vcmRzLFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBIaWdobGlnaHRUeXBlLkZMT1c6XG4gICAgICAgICAgICAgIGxheWVycy5wdXNoKFxuICAgICAgICAgICAgICAgIG5ldyBGbG93TGluZXNMYXllcih7XG4gICAgICAgICAgICAgICAgICAuLi50aGlzLmdldFN1YkxheWVyUHJvcHMoe1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2Zsb3ctaGlnaGxpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaGlnaGxpZ2h0ZWRPYmplY3QubGluZUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIGRyYXdPdXRsaW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwaWNrYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVDb2xvcjogY29sb3JBc1JnYmEodGhpcy5wcm9wcy5oaWdobGlnaHRDb2xvciksXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmVUaGlja25lc3M6IDEsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvY2F0aW9uTGFiZWxzKSB7XG4gICAgICAgIGxheWVycy5wdXNoKFxuICAgICAgICAgIG5ldyBUZXh0TGF5ZXIoXG4gICAgICAgICAgICB0aGlzLmdldFN1YkxheWVyUHJvcHMoe1xuICAgICAgICAgICAgICBpZDogJ2xvY2F0aW9uLWxhYmVscycsXG4gICAgICAgICAgICAgIGRhdGE6IGxvY2F0aW9uTGFiZWxzLFxuICAgICAgICAgICAgICBtYXhXaWR0aDogMTAwMCxcbiAgICAgICAgICAgICAgcGlja2FibGU6IGZhbHNlLFxuICAgICAgICAgICAgICBmb250RmFtaWx5OiAnSGVsdmV0aWNhJyxcbiAgICAgICAgICAgICAgZ2V0UGl4ZWxPZmZzZXQ6IChkOiBzdHJpbmcsIHtpbmRleH06IHtpbmRleDogbnVtYmVyfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBnZXRPdXRlckNpcmNsZVJhZGl1c0J5SW5kZXgoY2lyY2xlQXR0cmlidXRlcywgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMCwgciArIDVdO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBnZXRQb3NpdGlvbjogKGQ6IHN0cmluZywge2luZGV4fToge2luZGV4OiBudW1iZXJ9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zID0gZ2V0TG9jYXRpb25Db29yZHNCeUluZGV4KGNpcmNsZUF0dHJpYnV0ZXMsIGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBnZXRUZXh0OiAoZDogc3RyaW5nKSA9PiBkLFxuICAgICAgICAgICAgICBnZXRTaXplOiAxMCxcbiAgICAgICAgICAgICAgZ2V0Q29sb3I6IFsyNTUsIDI1NSwgMjU1LCAyNTVdLFxuICAgICAgICAgICAgICBnZXRBbmdsZTogMCxcbiAgICAgICAgICAgICAgZ2V0VGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICAgIGdldEFsaWdubWVudEJhc2VsaW5lOiAndG9wJyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheWVycztcbiAgfVxufVxuXG5mdW5jdGlvbiBwaWNrVmlld3BvcnRQcm9wcyh2aWV3cG9ydDogUmVjb3JkPHN0cmluZywgYW55Pik6IFZpZXdwb3J0UHJvcHMge1xuICBjb25zdCB7d2lkdGgsIGhlaWdodCwgbG9uZ2l0dWRlLCBsYXRpdHVkZSwgem9vbSwgcGl0Y2gsIGJlYXJpbmd9ID0gdmlld3BvcnQ7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGxvbmdpdHVkZSxcbiAgICBsYXRpdHVkZSxcbiAgICB6b29tLFxuICAgIHBpdGNoLFxuICAgIGJlYXJpbmcsXG4gIH07XG59XG4iXX0=