/*
 * Copyright (c) Flowmap.gl contributors
 * Copyright (c) 2018-2020 Teralytics
 * SPDX-License-Identifier: Apache-2.0
 */
export default `\
#define SHADER_NAME flow-line-layer-vertex-shader

attribute vec3 positions;
attribute vec3 normals;
attribute vec4 instanceColors;
attribute float instanceThickness;    // 0..0.5
attribute vec3 instanceSourcePositions;
attribute vec3 instanceTargetPositions;
attribute vec3 instanceSourcePositions64Low;
attribute vec3 instanceTargetPositions64Low;
attribute vec3 instancePickingColors;
attribute vec2 instanceEndpointOffsets;
attribute float instancePickable;

uniform vec4 outlineColor;
uniform float thicknessUnit;
uniform float gap;
uniform float opacity;

varying vec4 vColor;
varying vec2 uv;

void main(void) {
  geometry.worldPosition = instanceSourcePositions;
  geometry.worldPositionAlt = instanceTargetPositions;
  
  // Position
  vec4 source_commonspace;    
  vec4 target_commonspace;
  vec4 source = project_position_to_clipspace(instanceSourcePositions, instanceSourcePositions64Low, vec3(0.), source_commonspace);
  vec4 target = project_position_to_clipspace(instanceTargetPositions, instanceTargetPositions64Low, vec3(0.), target_commonspace);

  // linear interpolation of source & target to pick right coord
  float sourceOrTarget = positions.x;
  geometry.position = mix(source_commonspace, target_commonspace, sourceOrTarget);
  uv = positions.xy;
  geometry.uv = uv;
  if (instancePickable > 0.5) {
    geometry.pickingColor = instancePickingColors;
  }
  
  // set the clamp limits in pixel size 
  float lengthCommon = length(target_commonspace - source_commonspace);    
  vec2 offsetDistances = project_pixel_size(positions.yz) * thicknessUnit;
  
  vec2 limitedOffsetDistances = clamp(   
    project_pixel_size(positions.yz) * thicknessUnit,
    -lengthCommon*.8, lengthCommon*.8
  );
  float startOffsetCommon = project_pixel_size(instanceEndpointOffsets[0]);
  float endOffsetCommon = project_pixel_size(instanceEndpointOffsets[1]);
  float endpointOffset = mix(
    clamp(startOffsetCommon, 0.0, lengthCommon*.2),
    -clamp(endOffsetCommon, 0.0, lengthCommon*.2),
    positions.x
  );

  vec2 flowlineDir = normalize(target_commonspace.xy - source_commonspace.xy);
  vec2 perpendicularDir = vec2(-flowlineDir.y, flowlineDir.x);
  vec2 normalsCommon = project_pixel_size(normals.xy);
  float gapCommon = project_pixel_size(gap);
  vec3 offsetCommon = vec3(
    flowlineDir * (instanceThickness * limitedOffsetDistances[1] + normalsCommon.y + endpointOffset * 1.05) -
    perpendicularDir * (instanceThickness * limitedOffsetDistances[0] + gapCommon + normalsCommon.x),
    0.0
  );
  
  DECKGL_FILTER_SIZE(offsetCommon, geometry);
  vec4 position_commonspace = mix(source_commonspace, target_commonspace, sourceOrTarget);
  vec4 offset_commonspace = vec4(offsetCommon, 0.0);
  gl_Position = project_common_position_to_clipspace(position_commonspace + offset_commonspace);
      
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  
  vec4 fillColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;
  vColor = mix(fillColor, vec4(outlineColor.xyz, outlineColor.w * fillColor.w), normals.z);
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmxvd0xpbmVzTGF5ZXJWZXJ0ZXguZ2xzbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9GbG93TGluZXNMYXllci9GbG93TGluZXNMYXllclZlcnRleC5nbHNsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7O0dBSUc7QUFDSCxlQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBK0VkLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSBGbG93bWFwLmdsIGNvbnRyaWJ1dG9yc1xuICogQ29weXJpZ2h0IChjKSAyMDE4LTIwMjAgVGVyYWx5dGljc1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgYFxcXG4jZGVmaW5lIFNIQURFUl9OQU1FIGZsb3ctbGluZS1sYXllci12ZXJ0ZXgtc2hhZGVyXG5cbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWMzIG5vcm1hbHM7XG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUNvbG9ycztcbmF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZVRoaWNrbmVzczsgICAgLy8gMC4uMC41XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVNvdXJjZVBvc2l0aW9ucztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlVGFyZ2V0UG9zaXRpb25zO1xuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VTb3VyY2VQb3NpdGlvbnM2NExvdztcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlVGFyZ2V0UG9zaXRpb25zNjRMb3c7XG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XG5hdHRyaWJ1dGUgdmVjMiBpbnN0YW5jZUVuZHBvaW50T2Zmc2V0cztcbmF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZVBpY2thYmxlO1xuXG51bmlmb3JtIHZlYzQgb3V0bGluZUNvbG9yO1xudW5pZm9ybSBmbG9hdCB0aGlja25lc3NVbml0O1xudW5pZm9ybSBmbG9hdCBnYXA7XG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XG5cbnZhcnlpbmcgdmVjNCB2Q29sb3I7XG52YXJ5aW5nIHZlYzIgdXY7XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIGdlb21ldHJ5LndvcmxkUG9zaXRpb24gPSBpbnN0YW5jZVNvdXJjZVBvc2l0aW9ucztcbiAgZ2VvbWV0cnkud29ybGRQb3NpdGlvbkFsdCA9IGluc3RhbmNlVGFyZ2V0UG9zaXRpb25zO1xuICBcbiAgLy8gUG9zaXRpb25cbiAgdmVjNCBzb3VyY2VfY29tbW9uc3BhY2U7ICAgIFxuICB2ZWM0IHRhcmdldF9jb21tb25zcGFjZTtcbiAgdmVjNCBzb3VyY2UgPSBwcm9qZWN0X3Bvc2l0aW9uX3RvX2NsaXBzcGFjZShpbnN0YW5jZVNvdXJjZVBvc2l0aW9ucywgaW5zdGFuY2VTb3VyY2VQb3NpdGlvbnM2NExvdywgdmVjMygwLiksIHNvdXJjZV9jb21tb25zcGFjZSk7XG4gIHZlYzQgdGFyZ2V0ID0gcHJvamVjdF9wb3NpdGlvbl90b19jbGlwc3BhY2UoaW5zdGFuY2VUYXJnZXRQb3NpdGlvbnMsIGluc3RhbmNlVGFyZ2V0UG9zaXRpb25zNjRMb3csIHZlYzMoMC4pLCB0YXJnZXRfY29tbW9uc3BhY2UpO1xuXG4gIC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uIG9mIHNvdXJjZSAmIHRhcmdldCB0byBwaWNrIHJpZ2h0IGNvb3JkXG4gIGZsb2F0IHNvdXJjZU9yVGFyZ2V0ID0gcG9zaXRpb25zLng7XG4gIGdlb21ldHJ5LnBvc2l0aW9uID0gbWl4KHNvdXJjZV9jb21tb25zcGFjZSwgdGFyZ2V0X2NvbW1vbnNwYWNlLCBzb3VyY2VPclRhcmdldCk7XG4gIHV2ID0gcG9zaXRpb25zLnh5O1xuICBnZW9tZXRyeS51diA9IHV2O1xuICBpZiAoaW5zdGFuY2VQaWNrYWJsZSA+IDAuNSkge1xuICAgIGdlb21ldHJ5LnBpY2tpbmdDb2xvciA9IGluc3RhbmNlUGlja2luZ0NvbG9ycztcbiAgfVxuICBcbiAgLy8gc2V0IHRoZSBjbGFtcCBsaW1pdHMgaW4gcGl4ZWwgc2l6ZSBcbiAgZmxvYXQgbGVuZ3RoQ29tbW9uID0gbGVuZ3RoKHRhcmdldF9jb21tb25zcGFjZSAtIHNvdXJjZV9jb21tb25zcGFjZSk7ICAgIFxuICB2ZWMyIG9mZnNldERpc3RhbmNlcyA9IHByb2plY3RfcGl4ZWxfc2l6ZShwb3NpdGlvbnMueXopICogdGhpY2tuZXNzVW5pdDtcbiAgXG4gIHZlYzIgbGltaXRlZE9mZnNldERpc3RhbmNlcyA9IGNsYW1wKCAgIFxuICAgIHByb2plY3RfcGl4ZWxfc2l6ZShwb3NpdGlvbnMueXopICogdGhpY2tuZXNzVW5pdCxcbiAgICAtbGVuZ3RoQ29tbW9uKi44LCBsZW5ndGhDb21tb24qLjhcbiAgKTtcbiAgZmxvYXQgc3RhcnRPZmZzZXRDb21tb24gPSBwcm9qZWN0X3BpeGVsX3NpemUoaW5zdGFuY2VFbmRwb2ludE9mZnNldHNbMF0pO1xuICBmbG9hdCBlbmRPZmZzZXRDb21tb24gPSBwcm9qZWN0X3BpeGVsX3NpemUoaW5zdGFuY2VFbmRwb2ludE9mZnNldHNbMV0pO1xuICBmbG9hdCBlbmRwb2ludE9mZnNldCA9IG1peChcbiAgICBjbGFtcChzdGFydE9mZnNldENvbW1vbiwgMC4wLCBsZW5ndGhDb21tb24qLjIpLFxuICAgIC1jbGFtcChlbmRPZmZzZXRDb21tb24sIDAuMCwgbGVuZ3RoQ29tbW9uKi4yKSxcbiAgICBwb3NpdGlvbnMueFxuICApO1xuXG4gIHZlYzIgZmxvd2xpbmVEaXIgPSBub3JtYWxpemUodGFyZ2V0X2NvbW1vbnNwYWNlLnh5IC0gc291cmNlX2NvbW1vbnNwYWNlLnh5KTtcbiAgdmVjMiBwZXJwZW5kaWN1bGFyRGlyID0gdmVjMigtZmxvd2xpbmVEaXIueSwgZmxvd2xpbmVEaXIueCk7XG4gIHZlYzIgbm9ybWFsc0NvbW1vbiA9IHByb2plY3RfcGl4ZWxfc2l6ZShub3JtYWxzLnh5KTtcbiAgZmxvYXQgZ2FwQ29tbW9uID0gcHJvamVjdF9waXhlbF9zaXplKGdhcCk7XG4gIHZlYzMgb2Zmc2V0Q29tbW9uID0gdmVjMyhcbiAgICBmbG93bGluZURpciAqIChpbnN0YW5jZVRoaWNrbmVzcyAqIGxpbWl0ZWRPZmZzZXREaXN0YW5jZXNbMV0gKyBub3JtYWxzQ29tbW9uLnkgKyBlbmRwb2ludE9mZnNldCAqIDEuMDUpIC1cbiAgICBwZXJwZW5kaWN1bGFyRGlyICogKGluc3RhbmNlVGhpY2tuZXNzICogbGltaXRlZE9mZnNldERpc3RhbmNlc1swXSArIGdhcENvbW1vbiArIG5vcm1hbHNDb21tb24ueCksXG4gICAgMC4wXG4gICk7XG4gIFxuICBERUNLR0xfRklMVEVSX1NJWkUob2Zmc2V0Q29tbW9uLCBnZW9tZXRyeSk7XG4gIHZlYzQgcG9zaXRpb25fY29tbW9uc3BhY2UgPSBtaXgoc291cmNlX2NvbW1vbnNwYWNlLCB0YXJnZXRfY29tbW9uc3BhY2UsIHNvdXJjZU9yVGFyZ2V0KTtcbiAgdmVjNCBvZmZzZXRfY29tbW9uc3BhY2UgPSB2ZWM0KG9mZnNldENvbW1vbiwgMC4wKTtcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X2NvbW1vbl9wb3NpdGlvbl90b19jbGlwc3BhY2UocG9zaXRpb25fY29tbW9uc3BhY2UgKyBvZmZzZXRfY29tbW9uc3BhY2UpO1xuICAgICAgXG4gIERFQ0tHTF9GSUxURVJfR0xfUE9TSVRJT04oZ2xfUG9zaXRpb24sIGdlb21ldHJ5KTtcbiAgXG4gIHZlYzQgZmlsbENvbG9yID0gdmVjNChpbnN0YW5jZUNvbG9ycy5yZ2IsIGluc3RhbmNlQ29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS47XG4gIHZDb2xvciA9IG1peChmaWxsQ29sb3IsIHZlYzQob3V0bGluZUNvbG9yLnh5eiwgb3V0bGluZUNvbG9yLncgKiBmaWxsQ29sb3IudyksIG5vcm1hbHMueik7XG4gIERFQ0tHTF9GSUxURVJfQ09MT1IodkNvbG9yLCBnZW9tZXRyeSk7XG59XG5gO1xuIl19