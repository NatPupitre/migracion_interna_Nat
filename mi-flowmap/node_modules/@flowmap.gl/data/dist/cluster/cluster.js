/*
 * Copyright (c) Flowmap.gl contributors
 * Copyright (c) 2018-2020 Teralytics
 * SPDX-License-Identifier: Apache-2.0
 */
import { min, rollup } from 'd3-array';
import KDBush from 'kdbush';
const defaultOptions = {
    minZoom: 0,
    maxZoom: 16,
    radius: 40,
    extent: 512,
    nodeSize: 64,
    makeClusterName: (id, numPoints) => undefined,
    makeClusterId: (id) => `{[${id}]}`,
};
export function isLeafPoint(p) {
    const { index } = p;
    return index != null;
}
export function isClusterPoint(p) {
    const { id } = p;
    return id != null;
}
export function clusterLocations(locations, locationAccessors, getLocationWeight, options) {
    const { getLocationLon, getLocationLat, getLocationId } = locationAccessors;
    const opts = {
        ...defaultOptions,
        ...options,
    };
    const { minZoom, maxZoom, nodeSize, makeClusterName, makeClusterId } = opts;
    const trees = new Array(maxZoom + 1);
    // generate a cluster object for each point and index input points into a KD-tree
    let clusters = new Array();
    let locationsCount = 0;
    for (const location of locations) {
        const x = getLocationLon(location);
        const y = getLocationLat(location);
        clusters.push({
            x: lngX(x),
            y: latY(y),
            weight: getLocationWeight(getLocationId(location)),
            zoom: Infinity,
            index: locationsCount,
            parentId: -1,
            location,
        });
        locationsCount++;
    }
    const makeBush = (points) => {
        const bush = new KDBush(points.length, nodeSize, Float32Array);
        for (let i = 0; i < points.length; i++) {
            bush.add(points[i].x, points[i].y);
        }
        bush.finish();
        bush.points = points;
        return bush;
    };
    // cluster points on max zoom, then cluster the results on previous zoom, etc.;
    // results in a cluster hierarchy across zoom levels
    trees[maxZoom + 1] = makeBush(clusters);
    let prevZoom = maxZoom + 1;
    for (let z = maxZoom; z >= minZoom; z--) {
        // create a new set of clusters for the zoom and index them with a KD-tree
        const _clusters = cluster(clusters, z, trees[prevZoom], opts);
        if (_clusters.length === clusters.length) {
            // same number of clusters => move the higher level clusters up
            // no need to keep the same data on multiple levels
            trees[z] = trees[prevZoom];
            trees[prevZoom] = undefined;
            prevZoom = z;
            clusters = _clusters;
        }
        else {
            prevZoom = z;
            clusters = _clusters;
            trees[z] = makeBush(clusters);
        }
    }
    if (trees.length === 0) {
        return [];
    }
    const numbersOfClusters = trees.map((d) => d?.points.length);
    const minClusters = min(numbersOfClusters.filter((d) => d > 0));
    let maxAvailZoom = findIndexOfMax(numbersOfClusters) ?? numbersOfClusters.length - 1;
    const numUniqueLocations = countUniqueLocations(locations, locationAccessors);
    if (numUniqueLocations < locationsCount) {
        // Duplicate locations would be clustered together at any zoom level which can lead to having too many zooms.
        // To avoid that, we need to find the max zoom level that has less or equal clusters than unique locations
        // and drop all zoom levels beyond that (except the unclustered level).
        const maxClustersZoom = findLastIndex(numbersOfClusters, (d) => d <= numUniqueLocations);
        if (maxClustersZoom >= 0) {
            // Now, move the unclustered points to the next zoom level to avoid having a gap
            if (maxClustersZoom < maxAvailZoom) {
                trees[maxClustersZoom + 1] = trees[maxAvailZoom];
                trees.splice(maxClustersZoom + 2); // Remove all zoom levels beyond maxClustersZoom
            }
            maxAvailZoom = maxClustersZoom + 1;
        }
    }
    const minAvailZoom = Math.min(maxAvailZoom, minClusters ? numbersOfClusters.lastIndexOf(minClusters) : maxAvailZoom);
    const clusterLevels = new Array();
    prevZoom = NaN;
    for (let zoom = maxAvailZoom; zoom >= minAvailZoom; zoom--) {
        let childrenByParent;
        const tree = trees[zoom];
        if (!tree)
            continue;
        if (trees[prevZoom] && zoom < maxAvailZoom) {
            childrenByParent = rollup(trees[prevZoom].points, (points) => points.map((p) => p.id ? makeClusterId(p.id) : getLocationId(p.location)), (point) => point.parentId);
        }
        const nodes = [];
        for (const point of tree.points) {
            const { x, y, numPoints, location } = point;
            if (isLeafPoint(point)) {
                nodes.push({
                    id: getLocationId(location),
                    zoom,
                    lat: getLocationLat(location),
                    lon: getLocationLon(location),
                });
            }
            else if (isClusterPoint(point)) {
                const { id } = point;
                const children = childrenByParent && childrenByParent.get(id);
                if (!children) {
                    // Might happen if there are multiple locations with same coordinates
                    console.warn(`Omitting cluster with no children, point:`, point);
                    continue;
                }
                const cluster = {
                    id: makeClusterId(id),
                    name: makeClusterName(id, numPoints),
                    zoom,
                    lat: yLat(y),
                    lon: xLng(x),
                    children: children ?? [],
                };
                nodes.push(cluster);
            }
        }
        clusterLevels.push({
            zoom,
            nodes,
        });
        prevZoom = zoom;
    }
    return clusterLevels;
}
function createCluster(x, y, id, numPoints, weight) {
    return {
        x,
        y,
        zoom: Infinity,
        id,
        parentId: -1,
        numPoints,
        weight,
    };
}
function cluster(points, zoom, tree, options) {
    const clusters = [];
    const { radius, extent } = options;
    const r = radius / (extent * Math.pow(2, zoom));
    // loop through each point
    for (let i = 0; i < points.length; i++) {
        const p = points[i];
        // if we've already visited the point at this zoom level, skip it
        if (p.zoom <= zoom) {
            continue;
        }
        p.zoom = zoom;
        // find all nearby points
        const neighborIds = tree.within(p.x, p.y, r);
        let weight = p.weight || 1;
        let numPoints = isClusterPoint(p) ? p.numPoints : 1;
        let wx = p.x * weight;
        let wy = p.y * weight;
        // encode both zoom and point index on which the cluster originated
        const id = (i << 5) + (zoom + 1);
        for (const neighborId of neighborIds) {
            const b = tree.points[neighborId];
            // filter out neighbors that are already processed
            if (b.zoom <= zoom) {
                continue;
            }
            b.zoom = zoom; // save the zoom (so it doesn't get processed twice)
            const weight2 = b.weight || 1;
            const numPoints2 = b.numPoints || 1;
            wx += b.x * weight2; // accumulate coordinates for calculating weighted center
            wy += b.y * weight2;
            weight += weight2;
            numPoints += numPoints2;
            b.parentId = id;
        }
        if (numPoints === 1) {
            clusters.push(p);
        }
        else {
            p.parentId = id;
            clusters.push(createCluster(wx / weight, wy / weight, id, numPoints, weight));
        }
    }
    return clusters;
}
// spherical mercator to longitude/latitude
function xLng(x) {
    return (x - 0.5) * 360;
}
function yLat(y) {
    const y2 = ((180 - y * 360) * Math.PI) / 180;
    return (360 * Math.atan(Math.exp(y2))) / Math.PI - 90;
}
// longitude/latitude to spherical mercator in [0..1] range
function lngX(lng) {
    return lng / 360 + 0.5;
}
function latY(lat) {
    const sin = Math.sin((lat * Math.PI) / 180);
    const y = 0.5 - (0.25 * Math.log((1 + sin) / (1 - sin))) / Math.PI;
    return y < 0 ? 0 : y > 1 ? 1 : y;
}
function getX(p) {
    return p.x;
}
function getY(p) {
    return p.y;
}
function countUniqueLocations(locations, locationAccessors) {
    const { getLocationLon, getLocationLat } = locationAccessors;
    const countByLatLon = new Map();
    let uniqueCnt = 0;
    for (const loc of locations) {
        const lon = getLocationLon(loc);
        const lat = getLocationLat(loc);
        const key = `${lon},${lat}`;
        const prev = countByLatLon.get(key);
        if (!prev) {
            uniqueCnt++;
        }
        countByLatLon.set(key, prev ? prev + 1 : 1);
    }
    return uniqueCnt;
}
function findIndexOfMax(arr) {
    let max = -Infinity;
    let maxIndex = undefined;
    for (let i = 0; i < arr.length; i++) {
        const value = arr[i];
        if (typeof value === 'number') {
            if (value > max) {
                max = value;
                maxIndex = i;
            }
        }
    }
    return maxIndex;
}
function findLastIndex(arr, predicate) {
    for (let i = arr.length - 1; i >= 0; i--) {
        if (predicate(arr[i], i, arr)) {
            return i;
        }
    }
    return -1;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2x1c3Rlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jbHVzdGVyL2NsdXN0ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7R0FJRztBQUVILE9BQU8sRUFBQyxHQUFHLEVBQUUsTUFBTSxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQ3JDLE9BQU8sTUFBTSxNQUFNLFFBQVEsQ0FBQztBQWtDNUIsTUFBTSxjQUFjLEdBQVk7SUFDOUIsT0FBTyxFQUFFLENBQUM7SUFDVixPQUFPLEVBQUUsRUFBRTtJQUNYLE1BQU0sRUFBRSxFQUFFO0lBQ1YsTUFBTSxFQUFFLEdBQUc7SUFDWCxRQUFRLEVBQUUsRUFBRTtJQUNaLGVBQWUsRUFBRSxDQUFDLEVBQVUsRUFBRSxTQUFpQixFQUFFLEVBQUUsQ0FBQyxTQUFTO0lBQzdELGFBQWEsRUFBRSxDQUFDLEVBQVUsRUFBRSxFQUFFLENBQUMsS0FBSyxFQUFFLElBQUk7Q0FDM0MsQ0FBQztBQXNCRixNQUFNLFVBQVUsV0FBVyxDQUFJLENBQVc7SUFDeEMsTUFBTSxFQUFDLEtBQUssRUFBQyxHQUFHLENBQWlCLENBQUM7SUFDbEMsT0FBTyxLQUFLLElBQUksSUFBSSxDQUFDO0FBQ3ZCLENBQUM7QUFFRCxNQUFNLFVBQVUsY0FBYyxDQUFJLENBQVc7SUFDM0MsTUFBTSxFQUFDLEVBQUUsRUFBQyxHQUFHLENBQWlCLENBQUM7SUFDL0IsT0FBTyxFQUFFLElBQUksSUFBSSxDQUFDO0FBQ3BCLENBQUM7QUFJRCxNQUFNLFVBQVUsZ0JBQWdCLENBQzlCLFNBQXNCLEVBQ3RCLGlCQUF1QyxFQUN2QyxpQkFBdUMsRUFDdkMsT0FBMEI7SUFFMUIsTUFBTSxFQUFDLGNBQWMsRUFBRSxjQUFjLEVBQUUsYUFBYSxFQUFDLEdBQUcsaUJBQWlCLENBQUM7SUFDMUUsTUFBTSxJQUFJLEdBQUc7UUFDWCxHQUFHLGNBQWM7UUFDakIsR0FBRyxPQUFPO0tBQ1gsQ0FBQztJQUNGLE1BQU0sRUFBQyxPQUFP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LENBQUM7YUFDZDtTQUNGO0tBQ0Y7SUFFRCxPQUFPLFFBQVEsQ0FBQztBQUNsQixDQUFDO0FBRUQsU0FBUyxhQUFhLENBQ3BCLEdBQVEsRUFDUixTQUEyRDtJQUUzRCxLQUFLLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDeEMsSUFBSSxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRTtZQUM3QixPQUFPLENBQUMsQ0FBQztTQUNWO0tBQ0Y7SUFDRCxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQ1osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIEZsb3dtYXAuZ2wgY29udHJpYnV0b3JzXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTgtMjAyMCBUZXJhbHl0aWNzXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbmltcG9ydCB7bWluLCByb2xsdXB9IGZyb20gJ2QzLWFycmF5JztcbmltcG9ydCBLREJ1c2ggZnJvbSAna2RidXNoJztcbmltcG9ydCB7TG9jYXRpb25XZWlnaHRHZXR0ZXJ9IGZyb20gJy4vQ2x1c3RlckluZGV4JztcbmltcG9ydCB7Q2x1c3RlciwgQ2x1c3RlckxldmVsLCBDbHVzdGVyTm9kZSwgTG9jYXRpb25BY2Nlc3NvcnN9IGZyb20gJy4uL3R5cGVzJztcblxuLyoqXG4gKiBUaGUgY29kZSBpbiB0aGlzIGZpbGUgaXMgYSBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L3N1cGVyY2x1c3RlclxuICpcbiAqICBJU0MgTGljZW5zZVxuICpcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYsIE1hcGJveFxuICpcbiAqICBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZVxuICogIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2VcbiAqICBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cbiAqXG4gKiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxuICogIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkRcbiAqICBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbiAqICBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TU1xuICogIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUlxuICogIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0ZcbiAqICBUSElTIFNPRlRXQVJFLlxuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9ucyB7XG4gIG1pblpvb206IG51bWJlcjsgLy8gbWluIHpvb20gdG8gZ2VuZXJhdGUgY2x1c3RlcnMgb25cbiAgbWF4Wm9vbTogbnVtYmVyOyAvLyBtYXggem9vbSBsZXZlbCB0byBjbHVzdGVyIHRoZSBwb2ludHMgb25cbiAgcmFkaXVzOiBudW1iZXI7IC8vIGNsdXN0ZXIgcmFkaXVzIGluIHBpeGVsc1xuICBleHRlbnQ6IG51bWJlcjsgLy8gdGlsZSBleHRlbnQgKHJhZGl1cyBpcyBjYWxjdWxhdGVkIHJlbGF0aXZlIHRvIGl0KVxuICBub2RlU2l6ZTogbnVtYmVyOyAvLyBzaXplIG9mIHRoZSBLRC10cmVlIGxlYWYgbm9kZSwgYWZmZWN0cyBwZXJmb3JtYW5jZVxuICBtYWtlQ2x1c3Rlck5hbWU6IChpZDogbnVtYmVyLCBudW1Qb2ludHM6IG51bWJlcikgPT4gc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBtYWtlQ2x1c3RlcklkOiAoaWQ6IG51bWJlcikgPT4gc3RyaW5nO1xufVxuXG5jb25zdCBkZWZhdWx0T3B0aW9uczogT3B0aW9ucyA9IHtcbiAgbWluWm9vbTogMCxcbiAgbWF4Wm9vbTogMTYsXG4gIHJhZGl1czogNDAsXG4gIGV4dGVudDogNTEyLFxuICBub2RlU2l6ZTogNjQsXG4gIG1ha2VDbHVzdGVyTmFtZTogKGlkOiBudW1iZXIsIG51bVBvaW50czogbnVtYmVyKSA9PiB1bmRlZmluZWQsXG4gIG1ha2VDbHVzdGVySWQ6IChpZDogbnVtYmVyKSA9PiBge1ske2lkfV19YCxcbn07XG5cbmludGVyZmFjZSBCYXNlUG9pbnQge1xuICB4OiBudW1iZXI7IC8vIHByb2plY3RlZCBwb2ludCBjb29yZGluYXRlc1xuICB5OiBudW1iZXI7XG4gIHdlaWdodDogbnVtYmVyO1xuICB6b29tOiBudW1iZXI7IC8vIHRoZSBsYXN0IHpvb20gdGhlIHBvaW50IHdhcyBwcm9jZXNzZWQgYXRcbiAgcGFyZW50SWQ6IG51bWJlcjsgLy8gcGFyZW50IGNsdXN0ZXIgaWRcbn1cblxuaW50ZXJmYWNlIExlYWZQb2ludDxMPiBleHRlbmRzIEJhc2VQb2ludCB7XG4gIGluZGV4OiBudW1iZXI7IC8vIGluZGV4IG9mIHRoZSBzb3VyY2UgZmVhdHVyZSBpbiB0aGUgb3JpZ2luYWwgaW5wdXQgYXJyYXksXG4gIGxvY2F0aW9uOiBMO1xufVxuXG5pbnRlcmZhY2UgQ2x1c3RlclBvaW50IGV4dGVuZHMgQmFzZVBvaW50IHtcbiAgaWQ6IG51bWJlcjtcbiAgbnVtUG9pbnRzOiBudW1iZXI7XG59XG5cbnR5cGUgUG9pbnQ8TD4gPSBMZWFmUG9pbnQ8TD4gfCBDbHVzdGVyUG9pbnQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xlYWZQb2ludDxMPihwOiBQb2ludDxMPik6IHAgaXMgTGVhZlBvaW50PEw+IHtcbiAgY29uc3Qge2luZGV4fSA9IHAgYXMgTGVhZlBvaW50PEw+O1xuICByZXR1cm4gaW5kZXggIT0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2x1c3RlclBvaW50PEw+KHA6IFBvaW50PEw+KTogcCBpcyBDbHVzdGVyUG9pbnQge1xuICBjb25zdCB7aWR9ID0gcCBhcyBDbHVzdGVyUG9pbnQ7XG4gIHJldHVybiBpZCAhPSBudWxsO1xufVxuXG50eXBlIFpvb21MZXZlbEtEQnVzaCA9IGFueTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNsdXN0ZXJMb2NhdGlvbnM8TD4oXG4gIGxvY2F0aW9uczogSXRlcmFibGU8TD4sXG4gIGxvY2F0aW9uQWNjZXNzb3JzOiBMb2NhdGlvbkFjY2Vzc29yczxMPixcbiAgZ2V0TG9jYXRpb25XZWlnaHQ6IExvY2F0aW9uV2VpZ2h0R2V0dGVyLFxuICBvcHRpb25zPzogUGFydGlhbDxPcHRpb25zPixcbik6IENsdXN0ZXJMZXZlbFtdIHtcbiAgY29uc3Qge2dldExvY2F0aW9uTG9uLCBnZXRMb2NhdGlvbkxhdCwgZ2V0TG9jYXRpb25JZH0gPSBsb2NhdGlvbkFjY2Vzc29ycztcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAuLi5vcHRpb25zLFxuICB9O1xuICBjb25zdCB7bWluWm9vbSwgbWF4Wm9vbSwgbm9kZVNpemUsIG1ha2VDbHVzdGVyTmFtZSwgbWFrZUNsdXN0ZXJJZH0gPSBvcHRzO1xuXG4gIGNvbnN0IHRyZWVzID0gbmV3IEFycmF5PFpvb21MZXZlbEtEQnVzaD4obWF4Wm9vbSArIDEpO1xuXG4gIC8vIGdlbmVyYXRlIGEgY2x1c3RlciBvYmplY3QgZm9yIGVhY2ggcG9pbnQgYW5kIGluZGV4IGlucHV0IHBvaW50cyBpbnRvIGEgS0QtdHJlZVxuICBsZXQgY2x1c3RlcnMgPSBuZXcgQXJyYXk8UG9pbnQ8TD4+KCk7XG4gIGxldCBsb2NhdGlvbnNDb3VudCA9IDA7XG4gIGZvciAoY29uc3QgbG9jYXRpb24gb2YgbG9jYXRpb25zKSB7XG4gICAgY29uc3QgeCA9IGdldExvY2F0aW9uTG9uKGxvY2F0aW9uKTtcbiAgICBjb25zdCB5ID0gZ2V0TG9jYXRpb25MYXQobG9jYXRpb24pO1xuICAgIGNsdXN0ZXJzLnB1c2goe1xuICAgICAgeDogbG5nWCh4KSwgLy8gcHJvamVjdGVkIHBvaW50IGNvb3JkaW5hdGVzXG4gICAgICB5OiBsYXRZKHkpLFxuICAgICAgd2VpZ2h0OiBnZXRMb2NhdGlvbldlaWdodChnZXRMb2NhdGlvbklkKGxvY2F0aW9uKSksXG4gICAgICB6b29tOiBJbmZpbml0eSwgLy8gdGhlIGxhc3Qgem9vbSB0aGUgcG9pbnQgd2FzIHByb2Nlc3NlZCBhdFxuICAgICAgaW5kZXg6IGxvY2F0aW9uc0NvdW50LCAvLyBpbmRleCBvZiB0aGUgc291cmNlIGZlYXR1cmUgaW4gdGhlIG9yaWdpbmFsIGlucHV0IGFycmF5LFxuICAgICAgcGFyZW50SWQ6IC0xLCAvLyBwYXJlbnQgY2x1c3RlciBpZFxuICAgICAgbG9jYXRpb24sXG4gICAgfSk7XG4gICAgbG9jYXRpb25zQ291bnQrKztcbiAgfVxuXG4gIGNvbnN0IG1ha2VCdXNoID0gKHBvaW50czogUG9pbnQ8TD5bXSkgPT4ge1xuICAgIGNvbnN0IGJ1c2ggPSBuZXcgS0RCdXNoKHBvaW50cy5sZW5ndGgsIG5vZGVTaXplLCBGbG9hdDMyQXJyYXkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidXNoLmFkZChwb2ludHNbaV0ueCwgcG9pbnRzW2ldLnkpO1xuICAgIH1cbiAgICBidXNoLmZpbmlzaCgpO1xuICAgIGJ1c2gucG9pbnRzID0gcG9pbnRzO1xuICAgIHJldHVybiBidXNoO1xuICB9O1xuXG4gIC8vIGNsdXN0ZXIgcG9pbnRzIG9uIG1heCB6b29tLCB0aGVuIGNsdXN0ZXIgdGhlIHJlc3VsdHMgb24gcHJldmlvdXMgem9vbSwgZXRjLjtcbiAgLy8gcmVzdWx0cyBpbiBhIGNsdXN0ZXIgaGllcmFyY2h5IGFjcm9zcyB6b29tIGxldmVsc1xuICB0cmVlc1ttYXhab29tICsgMV0gPSBtYWtlQnVzaChjbHVzdGVycyk7XG4gIGxldCBwcmV2Wm9vbSA9IG1heFpvb20gKyAxO1xuXG4gIGZvciAobGV0IHogPSBtYXhab29tOyB6ID49IG1pblpvb207IHotLSkge1xuICAgIC8vIGNyZWF0ZSBhIG5ldyBzZXQgb2YgY2x1c3RlcnMgZm9yIHRoZSB6b29tIGFuZCBpbmRleCB0aGVtIHdpdGggYSBLRC10cmVlXG4gICAgY29uc3QgX2NsdXN0ZXJzID0gY2x1c3RlcihjbHVzdGVycywgeiwgdHJlZXNbcHJldlpvb21dLCBvcHRzKTtcbiAgICBpZiAoX2NsdXN0ZXJzLmxlbmd0aCA9PT0gY2x1c3RlcnMubGVuZ3RoKSB7XG4gICAgICAvLyBzYW1lIG51bWJlciBvZiBjbHVzdGVycyA9PiBtb3ZlIHRoZSBoaWdoZXIgbGV2ZWwgY2x1c3RlcnMgdXBcbiAgICAgIC8vIG5vIG5lZWQgdG8ga2VlcCB0aGUgc2FtZSBkYXRhIG9uIG11bHRpcGxlIGxldmVsc1xuICAgICAgdHJlZXNbel0gPSB0cmVlc1twcmV2Wm9vbV07XG4gICAgICB0cmVlc1twcmV2Wm9vbV0gPSB1bmRlZmluZWQ7XG4gICAgICBwcmV2Wm9vbSA9IHo7XG4gICAgICBjbHVzdGVycyA9IF9jbHVzdGVycztcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldlpvb20gPSB6O1xuICAgICAgY2x1c3RlcnMgPSBfY2x1c3RlcnM7XG4gICAgICB0cmVlc1t6XSA9IG1ha2VCdXNoKGNsdXN0ZXJzKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHJlZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgbnVtYmVyc09mQ2x1c3RlcnM6IG51bWJlcltdID0gdHJlZXMubWFwKChkKSA9PiBkPy5wb2ludHMubGVuZ3RoKTtcbiAgY29uc3QgbWluQ2x1c3RlcnMgPSBtaW4obnVtYmVyc09mQ2x1c3RlcnMuZmlsdGVyKChkKSA9PiBkID4gMCkpO1xuXG4gIGxldCBtYXhBdmFpbFpvb20gPVxuICAgIGZpbmRJbmRleE9mTWF4KG51bWJlcnNPZkNsdXN0ZXJzKSA/PyBudW1iZXJzT2ZDbHVzdGVycy5sZW5ndGggLSAxO1xuXG4gIGNvbnN0IG51bVVuaXF1ZUxvY2F0aW9ucyA9IGNvdW50VW5pcXVlTG9jYXRpb25zKGxvY2F0aW9ucywgbG9jYXRpb25BY2Nlc3NvcnMpO1xuICBpZiAobnVtVW5pcXVlTG9jYXRpb25zIDwgbG9jYXRpb25zQ291bnQpIHtcbiAgICAvLyBEdXBsaWNhdGUgbG9jYXRpb25zIHdvdWxkIGJlIGNsdXN0ZXJlZCB0b2dldGhlciBhdCBhbnkgem9vbSBsZXZlbCB3aGljaCBjYW4gbGVhZCB0byBoYXZpbmcgdG9vIG1hbnkgem9vbXMuXG4gICAgLy8gVG8gYXZvaWQgdGhhdCwgd2UgbmVlZCB0byBmaW5kIHRoZSBtYXggem9vbSBsZXZlbCB0aGF0IGhhcyBsZXNzIG9yIGVxdWFsIGNsdXN0ZXJzIHRoYW4gdW5pcXVlIGxvY2F0aW9uc1xuICAgIC8vIGFuZCBkcm9wIGFsbCB6b29tIGxldmVscyBiZXlvbmQgdGhhdCAoZXhjZXB0IHRoZSB1bmNsdXN0ZXJlZCBsZXZlbCkuXG4gICAgY29uc3QgbWF4Q2x1c3RlcnNab29tID0gZmluZExhc3RJbmRleChcbiAgICAgIG51bWJlcnNPZkNsdXN0ZXJzLFxuICAgICAgKGQpID0+IGQgPD0gbnVtVW5pcXVlTG9jYXRpb25zLFxuICAgICk7XG4gICAgaWYgKG1heENsdXN0ZXJzWm9vbSA+PSAwKSB7XG4gICAgICAvLyBOb3csIG1vdmUgdGhlIHVuY2x1c3RlcmVkIHBvaW50cyB0byB0aGUgbmV4dCB6b29tIGxldmVsIHRvIGF2b2lkIGhhdmluZyBhIGdhcFxuICAgICAgaWYgKG1heENsdXN0ZXJzWm9vbSA8IG1heEF2YWlsWm9vbSkge1xuICAgICAgICB0cmVlc1ttYXhDbHVzdGVyc1pvb20gKyAxXSA9IHRyZWVzW21heEF2YWlsWm9vbV07XG4gICAgICAgIHRyZWVzLnNwbGljZShtYXhDbHVzdGVyc1pvb20gKyAyKTsgLy8gUmVtb3ZlIGFsbCB6b29tIGxldmVscyBiZXlvbmQgbWF4Q2x1c3RlcnNab29tXG4gICAgICB9XG4gICAgICBtYXhBdmFpbFpvb20gPSBtYXhDbHVzdGVyc1pvb20gKyAxO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG1pbkF2YWlsWm9vbSA9IE1hdGgubWluKFxuICAgIG1heEF2YWlsWm9vbSxcbiAgICBtaW5DbHVzdGVycyA/IG51bWJlcnNPZkNsdXN0ZXJzLmxhc3RJbmRleE9mKG1pbkNsdXN0ZXJzKSA6IG1heEF2YWlsWm9vbSxcbiAgKTtcblxuICBjb25zdCBjbHVzdGVyTGV2ZWxzID0gbmV3IEFycmF5PENsdXN0ZXJMZXZlbD4oKTtcbiAgcHJldlpvb20gPSBOYU47XG4gIGZvciAobGV0IHpvb20gPSBtYXhBdmFpbFpvb207IHpvb20gPj0gbWluQXZhaWxab29tOyB6b29tLS0pIHtcbiAgICBsZXQgY2hpbGRyZW5CeVBhcmVudDogTWFwPG51bWJlciwgKHN0cmluZyB8IG51bWJlcilbXT4gfCB1bmRlZmluZWQ7XG4gICAgY29uc3QgdHJlZSA9IHRyZWVzW3pvb21dO1xuICAgIGlmICghdHJlZSkgY29udGludWU7XG4gICAgaWYgKHRyZWVzW3ByZXZab29tXSAmJiB6b29tIDwgbWF4QXZhaWxab29tKSB7XG4gICAgICBjaGlsZHJlbkJ5UGFyZW50ID0gcm9sbHVwKFxuICAgICAgICB0cmVlc1twcmV2Wm9vbV0ucG9pbnRzLFxuICAgICAgICAocG9pbnRzOiBhbnlbXSkgPT5cbiAgICAgICAgICBwb2ludHMubWFwKChwOiBhbnkpID0+XG4gICAgICAgICAgICBwLmlkID8gbWFrZUNsdXN0ZXJJZChwLmlkKSA6IGdldExvY2F0aW9uSWQocC5sb2NhdGlvbiksXG4gICAgICAgICAgKSxcbiAgICAgICAgKHBvaW50OiBhbnkpID0+IHBvaW50LnBhcmVudElkLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlczogQ2x1c3Rlck5vZGVbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgcG9pbnQgb2YgdHJlZS5wb2ludHMpIHtcbiAgICAgIGNvbnN0IHt4LCB5LCBudW1Qb2ludHMsIGxvY2F0aW9ufSA9IHBvaW50O1xuICAgICAgaWYgKGlzTGVhZlBvaW50KHBvaW50KSkge1xuICAgICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgICBpZDogZ2V0TG9jYXRpb25JZChsb2NhdGlvbiksXG4gICAgICAgICAgem9vbSxcbiAgICAgICAgICBsYXQ6IGdldExvY2F0aW9uTGF0KGxvY2F0aW9uKSxcbiAgICAgICAgICBsb246IGdldExvY2F0aW9uTG9uKGxvY2F0aW9uKSxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzQ2x1c3RlclBvaW50KHBvaW50KSkge1xuICAgICAgICBjb25zdCB7aWR9ID0gcG9pbnQ7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gY2hpbGRyZW5CeVBhcmVudCAmJiBjaGlsZHJlbkJ5UGFyZW50LmdldChpZCk7XG4gICAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgICAvLyBNaWdodCBoYXBwZW4gaWYgdGhlcmUgYXJlIG11bHRpcGxlIGxvY2F0aW9ucyB3aXRoIHNhbWUgY29vcmRpbmF0ZXNcbiAgICAgICAgICBjb25zb2xlLndhcm4oYE9taXR0aW5nIGNsdXN0ZXIgd2l0aCBubyBjaGlsZHJlbiwgcG9pbnQ6YCwgcG9pbnQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsdXN0ZXIgPSB7XG4gICAgICAgICAgaWQ6IG1ha2VDbHVzdGVySWQoaWQpLFxuICAgICAgICAgIG5hbWU6IG1ha2VDbHVzdGVyTmFtZShpZCwgbnVtUG9pbnRzKSxcbiAgICAgICAgICB6b29tLFxuICAgICAgICAgIGxhdDogeUxhdCh5KSxcbiAgICAgICAgICBsb246IHhMbmcoeCksXG4gICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuID8/IFtdLFxuICAgICAgICB9IGFzIENsdXN0ZXI7XG4gICAgICAgIG5vZGVzLnB1c2goY2x1c3Rlcik7XG4gICAgICB9XG4gICAgfVxuICAgIGNsdXN0ZXJMZXZlbHMucHVzaCh7XG4gICAgICB6b29tLFxuICAgICAgbm9kZXMsXG4gICAgfSk7XG4gICAgcHJldlpvb20gPSB6b29tO1xuICB9XG4gIHJldHVybiBjbHVzdGVyTGV2ZWxzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbHVzdGVyKFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAgaWQ6IG51bWJlcixcbiAgbnVtUG9pbnRzOiBudW1iZXIsXG4gIHdlaWdodDogbnVtYmVyLFxuKTogQ2x1c3RlclBvaW50IHtcbiAgcmV0dXJuIHtcbiAgICB4LCAvLyB3ZWlnaHRlZCBjbHVzdGVyIGNlbnRlclxuICAgIHksXG4gICAgem9vbTogSW5maW5pdHksIC8vIHRoZSBsYXN0IHpvb20gdGhlIGNsdXN0ZXIgd2FzIHByb2Nlc3NlZCBhdFxuICAgIGlkLCAvLyBlbmNvZGVzIGluZGV4IG9mIHRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgY2x1c3RlciBhbmQgaXRzIHpvb20gbGV2ZWxcbiAgICBwYXJlbnRJZDogLTEsIC8vIHBhcmVudCBjbHVzdGVyIGlkXG4gICAgbnVtUG9pbnRzLFxuICAgIHdlaWdodCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2x1c3RlcjxMPihcbiAgcG9pbnRzOiBQb2ludDxMPltdLFxuICB6b29tOiBudW1iZXIsXG4gIHRyZWU6IFpvb21MZXZlbEtEQnVzaCxcbiAgb3B0aW9uczogT3B0aW9ucyxcbikge1xuICBjb25zdCBjbHVzdGVyczogUG9pbnQ8TD5bXSA9IFtdO1xuICBjb25zdCB7cmFkaXVzLCBleHRlbnR9ID0gb3B0aW9ucztcbiAgY29uc3QgciA9IHJhZGl1cyAvIChleHRlbnQgKiBNYXRoLnBvdygyLCB6b29tKSk7XG5cbiAgLy8gbG9vcCB0aHJvdWdoIGVhY2ggcG9pbnRcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwID0gcG9pbnRzW2ldO1xuICAgIC8vIGlmIHdlJ3ZlIGFscmVhZHkgdmlzaXRlZCB0aGUgcG9pbnQgYXQgdGhpcyB6b29tIGxldmVsLCBza2lwIGl0XG4gICAgaWYgKHAuem9vbSA8PSB6b29tKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcC56b29tID0gem9vbTtcblxuICAgIC8vIGZpbmQgYWxsIG5lYXJieSBwb2ludHNcbiAgICBjb25zdCBuZWlnaGJvcklkcyA9IHRyZWUud2l0aGluKHAueCwgcC55LCByKTtcblxuICAgIGxldCB3ZWlnaHQgPSBwLndlaWdodCB8fCAxO1xuICAgIGxldCBudW1Qb2ludHMgPSBpc0NsdXN0ZXJQb2ludChwKSA/IHAubnVtUG9pbnRzIDogMTtcbiAgICBsZXQgd3ggPSBwLnggKiB3ZWlnaHQ7XG4gICAgbGV0IHd5ID0gcC55ICogd2VpZ2h0O1xuXG4gICAgLy8gZW5jb2RlIGJvdGggem9vbSBhbmQgcG9pbnQgaW5kZXggb24gd2hpY2ggdGhlIGNsdXN0ZXIgb3JpZ2luYXRlZFxuICAgIGNvbnN0IGlkID0gKGkgPDwgNSkgKyAoem9vbSArIDEpO1xuXG4gICAgZm9yIChjb25zdCBuZWlnaGJvcklkIG9mIG5laWdoYm9ySWRzKSB7XG4gICAgICBjb25zdCBiID0gdHJlZS5wb2ludHNbbmVpZ2hib3JJZF07XG4gICAgICAvLyBmaWx0ZXIgb3V0IG5laWdoYm9ycyB0aGF0IGFyZSBhbHJlYWR5IHByb2Nlc3NlZFxuICAgICAgaWYgKGIuem9vbSA8PSB6b29tKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYi56b29tID0gem9vbTsgLy8gc2F2ZSB0aGUgem9vbSAoc28gaXQgZG9lc24ndCBnZXQgcHJvY2Vzc2VkIHR3aWNlKVxuXG4gICAgICBjb25zdCB3ZWlnaHQyID0gYi53ZWlnaHQgfHwgMTtcbiAgICAgIGNvbnN0IG51bVBvaW50czIgPSBiLm51bVBvaW50cyB8fCAxO1xuICAgICAgd3ggKz0gYi54ICogd2VpZ2h0MjsgLy8gYWNjdW11bGF0ZSBjb29yZGluYXRlcyBmb3IgY2FsY3VsYXRpbmcgd2VpZ2h0ZWQgY2VudGVyXG4gICAgICB3eSArPSBiLnkgKiB3ZWlnaHQyO1xuXG4gICAgICB3ZWlnaHQgKz0gd2VpZ2h0MjtcbiAgICAgIG51bVBvaW50cyArPSBudW1Qb2ludHMyO1xuICAgICAgYi5wYXJlbnRJZCA9IGlkO1xuICAgIH1cblxuICAgIGlmIChudW1Qb2ludHMgPT09IDEpIHtcbiAgICAgIGNsdXN0ZXJzLnB1c2gocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHAucGFyZW50SWQgPSBpZDtcbiAgICAgIGNsdXN0ZXJzLnB1c2goXG4gICAgICAgIGNyZWF0ZUNsdXN0ZXIod3ggLyB3ZWlnaHQsIHd5IC8gd2VpZ2h0LCBpZCwgbnVtUG9pbnRzLCB3ZWlnaHQpLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2x1c3RlcnM7XG59XG5cbi8vIHNwaGVyaWNhbCBtZXJjYXRvciB0byBsb25naXR1ZGUvbGF0aXR1ZGVcbmZ1bmN0aW9uIHhMbmcoeDogbnVtYmVyKSB7XG4gIHJldHVybiAoeCAtIDAuNSkgKiAzNjA7XG59XG5cbmZ1bmN0aW9uIHlMYXQoeTogbnVtYmVyKSB7XG4gIGNvbnN0IHkyID0gKCgxODAgLSB5ICogMzYwKSAqIE1hdGguUEkpIC8gMTgwO1xuICByZXR1cm4gKDM2MCAqIE1hdGguYXRhbihNYXRoLmV4cCh5MikpKSAvIE1hdGguUEkgLSA5MDtcbn1cblxuLy8gbG9uZ2l0dWRlL2xhdGl0dWRlIHRvIHNwaGVyaWNhbCBtZXJjYXRvciBpbiBbMC4uMV0gcmFuZ2VcbmZ1bmN0aW9uIGxuZ1gobG5nOiBudW1iZXIpIHtcbiAgcmV0dXJuIGxuZyAvIDM2MCArIDAuNTtcbn1cblxuZnVuY3Rpb24gbGF0WShsYXQ6IG51bWJlcikge1xuICBjb25zdCBzaW4gPSBNYXRoLnNpbigobGF0ICogTWF0aC5QSSkgLyAxODApO1xuICBjb25zdCB5ID0gMC41IC0gKDAuMjUgKiBNYXRoLmxvZygoMSArIHNpbikgLyAoMSAtIHNpbikpKSAvIE1hdGguUEk7XG4gIHJldHVybiB5IDwgMCA/IDAgOiB5ID4gMSA/IDEgOiB5O1xufVxuXG5mdW5jdGlvbiBnZXRYPEw+KHA6IFBvaW50PEw+KSB7XG4gIHJldHVybiBwLng7XG59XG5cbmZ1bmN0aW9uIGdldFk8TD4ocDogUG9pbnQ8TD4pIHtcbiAgcmV0dXJuIHAueTtcbn1cblxuZnVuY3Rpb24gY291bnRVbmlxdWVMb2NhdGlvbnM8TD4oXG4gIGxvY2F0aW9uczogSXRlcmFibGU8TD4sXG4gIGxvY2F0aW9uQWNjZXNzb3JzOiBMb2NhdGlvbkFjY2Vzc29yczxMPixcbikge1xuICBjb25zdCB7Z2V0TG9jYXRpb25Mb24sIGdldExvY2F0aW9uTGF0fSA9IGxvY2F0aW9uQWNjZXNzb3JzO1xuICBjb25zdCBjb3VudEJ5TGF0TG9uID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcbiAgbGV0IHVuaXF1ZUNudCA9IDA7XG4gIGZvciAoY29uc3QgbG9jIG9mIGxvY2F0aW9ucykge1xuICAgIGNvbnN0IGxvbiA9IGdldExvY2F0aW9uTG9uKGxvYyk7XG4gICAgY29uc3QgbGF0ID0gZ2V0TG9jYXRpb25MYXQobG9jKTtcbiAgICBjb25zdCBrZXkgPSBgJHtsb259LCR7bGF0fWA7XG4gICAgY29uc3QgcHJldiA9IGNvdW50QnlMYXRMb24uZ2V0KGtleSk7XG4gICAgaWYgKCFwcmV2KSB7XG4gICAgICB1bmlxdWVDbnQrKztcbiAgICB9XG4gICAgY291bnRCeUxhdExvbi5zZXQoa2V5LCBwcmV2ID8gcHJldiArIDEgOiAxKTtcbiAgfVxuICByZXR1cm4gdW5pcXVlQ250O1xufVxuXG5mdW5jdGlvbiBmaW5kSW5kZXhPZk1heChhcnI6IChudW1iZXIgfCB1bmRlZmluZWQpW10pOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBsZXQgbWF4ID0gLUluZmluaXR5O1xuICBsZXQgbWF4SW5kZXg6IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gYXJyW2ldO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgbWF4SW5kZXggPSBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXhJbmRleDtcbn1cblxuZnVuY3Rpb24gZmluZExhc3RJbmRleDxUPihcbiAgYXJyOiBUW10sXG4gIHByZWRpY2F0ZTogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyLCBhcnJheTogVFtdKSA9PiBib29sZWFuLFxuKTogbnVtYmVyIHtcbiAgZm9yIChsZXQgaSA9IGFyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyW2ldLCBpLCBhcnIpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuIl19